// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'torrent.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

TorrentQuickData _$TorrentQuickDataFromJson(Map<String, dynamic> json) {
  return _TorrentQuickData.fromJson(json);
}

/// @nodoc
mixin _$TorrentQuickData {
  int get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  int get downloadedBytes => throw _privateConstructorUsedError;
  int get sizeToDownloadBytes => throw _privateConstructorUsedError;
  int get sizeBytes => throw _privateConstructorUsedError;
  Duration get estimatedTimeLeft => throw _privateConstructorUsedError;
  int get downloadBytesPerSecond => throw _privateConstructorUsedError;
  bool get downloadLimited => throw _privateConstructorUsedError;
  int get uploadBytesPerSecond => throw _privateConstructorUsedError;
  bool get uploadLimited => throw _privateConstructorUsedError;
  TorrentState get state => throw _privateConstructorUsedError;
  TorrentPriority get priority => throw _privateConstructorUsedError;
  DateTime? get addedOn => throw _privateConstructorUsedError;
  DateTime? get completedOn => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TorrentQuickDataCopyWith<TorrentQuickData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TorrentQuickDataCopyWith<$Res> {
  factory $TorrentQuickDataCopyWith(
          TorrentQuickData value, $Res Function(TorrentQuickData) then) =
      _$TorrentQuickDataCopyWithImpl<$Res, TorrentQuickData>;
  @useResult
  $Res call(
      {int id,
      String name,
      int downloadedBytes,
      int sizeToDownloadBytes,
      int sizeBytes,
      Duration estimatedTimeLeft,
      int downloadBytesPerSecond,
      bool downloadLimited,
      int uploadBytesPerSecond,
      bool uploadLimited,
      TorrentState state,
      TorrentPriority priority,
      DateTime? addedOn,
      DateTime? completedOn});
}

/// @nodoc
class _$TorrentQuickDataCopyWithImpl<$Res, $Val extends TorrentQuickData>
    implements $TorrentQuickDataCopyWith<$Res> {
  _$TorrentQuickDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? downloadedBytes = null,
    Object? sizeToDownloadBytes = null,
    Object? sizeBytes = null,
    Object? estimatedTimeLeft = null,
    Object? downloadBytesPerSecond = null,
    Object? downloadLimited = null,
    Object? uploadBytesPerSecond = null,
    Object? uploadLimited = null,
    Object? state = null,
    Object? priority = null,
    Object? addedOn = freezed,
    Object? completedOn = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      downloadedBytes: null == downloadedBytes
          ? _value.downloadedBytes
          : downloadedBytes // ignore: cast_nullable_to_non_nullable
              as int,
      sizeToDownloadBytes: null == sizeToDownloadBytes
          ? _value.sizeToDownloadBytes
          : sizeToDownloadBytes // ignore: cast_nullable_to_non_nullable
              as int,
      sizeBytes: null == sizeBytes
          ? _value.sizeBytes
          : sizeBytes // ignore: cast_nullable_to_non_nullable
              as int,
      estimatedTimeLeft: null == estimatedTimeLeft
          ? _value.estimatedTimeLeft
          : estimatedTimeLeft // ignore: cast_nullable_to_non_nullable
              as Duration,
      downloadBytesPerSecond: null == downloadBytesPerSecond
          ? _value.downloadBytesPerSecond
          : downloadBytesPerSecond // ignore: cast_nullable_to_non_nullable
              as int,
      downloadLimited: null == downloadLimited
          ? _value.downloadLimited
          : downloadLimited // ignore: cast_nullable_to_non_nullable
              as bool,
      uploadBytesPerSecond: null == uploadBytesPerSecond
          ? _value.uploadBytesPerSecond
          : uploadBytesPerSecond // ignore: cast_nullable_to_non_nullable
              as int,
      uploadLimited: null == uploadLimited
          ? _value.uploadLimited
          : uploadLimited // ignore: cast_nullable_to_non_nullable
              as bool,
      state: null == state
          ? _value.state
          : state // ignore: cast_nullable_to_non_nullable
              as TorrentState,
      priority: null == priority
          ? _value.priority
          : priority // ignore: cast_nullable_to_non_nullable
              as TorrentPriority,
      addedOn: freezed == addedOn
          ? _value.addedOn
          : addedOn // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      completedOn: freezed == completedOn
          ? _value.completedOn
          : completedOn // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_TorrentQuickDataCopyWith<$Res>
    implements $TorrentQuickDataCopyWith<$Res> {
  factory _$$_TorrentQuickDataCopyWith(
          _$_TorrentQuickData value, $Res Function(_$_TorrentQuickData) then) =
      __$$_TorrentQuickDataCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int id,
      String name,
      int downloadedBytes,
      int sizeToDownloadBytes,
      int sizeBytes,
      Duration estimatedTimeLeft,
      int downloadBytesPerSecond,
      bool downloadLimited,
      int uploadBytesPerSecond,
      bool uploadLimited,
      TorrentState state,
      TorrentPriority priority,
      DateTime? addedOn,
      DateTime? completedOn});
}

/// @nodoc
class __$$_TorrentQuickDataCopyWithImpl<$Res>
    extends _$TorrentQuickDataCopyWithImpl<$Res, _$_TorrentQuickData>
    implements _$$_TorrentQuickDataCopyWith<$Res> {
  __$$_TorrentQuickDataCopyWithImpl(
      _$_TorrentQuickData _value, $Res Function(_$_TorrentQuickData) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? downloadedBytes = null,
    Object? sizeToDownloadBytes = null,
    Object? sizeBytes = null,
    Object? estimatedTimeLeft = null,
    Object? downloadBytesPerSecond = null,
    Object? downloadLimited = null,
    Object? uploadBytesPerSecond = null,
    Object? uploadLimited = null,
    Object? state = null,
    Object? priority = null,
    Object? addedOn = freezed,
    Object? completedOn = freezed,
  }) {
    return _then(_$_TorrentQuickData(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      downloadedBytes: null == downloadedBytes
          ? _value.downloadedBytes
          : downloadedBytes // ignore: cast_nullable_to_non_nullable
              as int,
      sizeToDownloadBytes: null == sizeToDownloadBytes
          ? _value.sizeToDownloadBytes
          : sizeToDownloadBytes // ignore: cast_nullable_to_non_nullable
              as int,
      sizeBytes: null == sizeBytes
          ? _value.sizeBytes
          : sizeBytes // ignore: cast_nullable_to_non_nullable
              as int,
      estimatedTimeLeft: null == estimatedTimeLeft
          ? _value.estimatedTimeLeft
          : estimatedTimeLeft // ignore: cast_nullable_to_non_nullable
              as Duration,
      downloadBytesPerSecond: null == downloadBytesPerSecond
          ? _value.downloadBytesPerSecond
          : downloadBytesPerSecond // ignore: cast_nullable_to_non_nullable
              as int,
      downloadLimited: null == downloadLimited
          ? _value.downloadLimited
          : downloadLimited // ignore: cast_nullable_to_non_nullable
              as bool,
      uploadBytesPerSecond: null == uploadBytesPerSecond
          ? _value.uploadBytesPerSecond
          : uploadBytesPerSecond // ignore: cast_nullable_to_non_nullable
              as int,
      uploadLimited: null == uploadLimited
          ? _value.uploadLimited
          : uploadLimited // ignore: cast_nullable_to_non_nullable
              as bool,
      state: null == state
          ? _value.state
          : state // ignore: cast_nullable_to_non_nullable
              as TorrentState,
      priority: null == priority
          ? _value.priority
          : priority // ignore: cast_nullable_to_non_nullable
              as TorrentPriority,
      addedOn: freezed == addedOn
          ? _value.addedOn
          : addedOn // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      completedOn: freezed == completedOn
          ? _value.completedOn
          : completedOn // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_TorrentQuickData
    with DiagnosticableTreeMixin
    implements _TorrentQuickData {
  const _$_TorrentQuickData(
      {required this.id,
      required this.name,
      required this.downloadedBytes,
      required this.sizeToDownloadBytes,
      required this.sizeBytes,
      required this.estimatedTimeLeft,
      required this.downloadBytesPerSecond,
      required this.downloadLimited,
      required this.uploadBytesPerSecond,
      required this.uploadLimited,
      required this.state,
      required this.priority,
      this.addedOn,
      this.completedOn});

  factory _$_TorrentQuickData.fromJson(Map<String, dynamic> json) =>
      _$$_TorrentQuickDataFromJson(json);

  @override
  final int id;
  @override
  final String name;
  @override
  final int downloadedBytes;
  @override
  final int sizeToDownloadBytes;
  @override
  final int sizeBytes;
  @override
  final Duration estimatedTimeLeft;
  @override
  final int downloadBytesPerSecond;
  @override
  final bool downloadLimited;
  @override
  final int uploadBytesPerSecond;
  @override
  final bool uploadLimited;
  @override
  final TorrentState state;
  @override
  final TorrentPriority priority;
  @override
  final DateTime? addedOn;
  @override
  final DateTime? completedOn;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'TorrentQuickData(id: $id, name: $name, downloadedBytes: $downloadedBytes, sizeToDownloadBytes: $sizeToDownloadBytes, sizeBytes: $sizeBytes, estimatedTimeLeft: $estimatedTimeLeft, downloadBytesPerSecond: $downloadBytesPerSecond, downloadLimited: $downloadLimited, uploadBytesPerSecond: $uploadBytesPerSecond, uploadLimited: $uploadLimited, state: $state, priority: $priority, addedOn: $addedOn, completedOn: $completedOn)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'TorrentQuickData'))
      ..add(DiagnosticsProperty('id', id))
      ..add(DiagnosticsProperty('name', name))
      ..add(DiagnosticsProperty('downloadedBytes', downloadedBytes))
      ..add(DiagnosticsProperty('sizeToDownloadBytes', sizeToDownloadBytes))
      ..add(DiagnosticsProperty('sizeBytes', sizeBytes))
      ..add(DiagnosticsProperty('estimatedTimeLeft', estimatedTimeLeft))
      ..add(
          DiagnosticsProperty('downloadBytesPerSecond', downloadBytesPerSecond))
      ..add(DiagnosticsProperty('downloadLimited', downloadLimited))
      ..add(DiagnosticsProperty('uploadBytesPerSecond', uploadBytesPerSecond))
      ..add(DiagnosticsProperty('uploadLimited', uploadLimited))
      ..add(DiagnosticsProperty('state', state))
      ..add(DiagnosticsProperty('priority', priority))
      ..add(DiagnosticsProperty('addedOn', addedOn))
      ..add(DiagnosticsProperty('completedOn', completedOn));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TorrentQuickData &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.downloadedBytes, downloadedBytes) ||
                other.downloadedBytes == downloadedBytes) &&
            (identical(other.sizeToDownloadBytes, sizeToDownloadBytes) ||
                other.sizeToDownloadBytes == sizeToDownloadBytes) &&
            (identical(other.sizeBytes, sizeBytes) ||
                other.sizeBytes == sizeBytes) &&
            (identical(other.estimatedTimeLeft, estimatedTimeLeft) ||
                other.estimatedTimeLeft == estimatedTimeLeft) &&
            (identical(other.downloadBytesPerSecond, downloadBytesPerSecond) ||
                other.downloadBytesPerSecond == downloadBytesPerSecond) &&
            (identical(other.downloadLimited, downloadLimited) ||
                other.downloadLimited == downloadLimited) &&
            (identical(other.uploadBytesPerSecond, uploadBytesPerSecond) ||
                other.uploadBytesPerSecond == uploadBytesPerSecond) &&
            (identical(other.uploadLimited, uploadLimited) ||
                other.uploadLimited == uploadLimited) &&
            (identical(other.state, state) || other.state == state) &&
            (identical(other.priority, priority) ||
                other.priority == priority) &&
            (identical(other.addedOn, addedOn) || other.addedOn == addedOn) &&
            (identical(other.completedOn, completedOn) ||
                other.completedOn == completedOn));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      name,
      downloadedBytes,
      sizeToDownloadBytes,
      sizeBytes,
      estimatedTimeLeft,
      downloadBytesPerSecond,
      downloadLimited,
      uploadBytesPerSecond,
      uploadLimited,
      state,
      priority,
      addedOn,
      completedOn);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_TorrentQuickDataCopyWith<_$_TorrentQuickData> get copyWith =>
      __$$_TorrentQuickDataCopyWithImpl<_$_TorrentQuickData>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TorrentQuickDataToJson(
      this,
    );
  }
}

abstract class _TorrentQuickData implements TorrentQuickData {
  const factory _TorrentQuickData(
      {required final int id,
      required final String name,
      required final int downloadedBytes,
      required final int sizeToDownloadBytes,
      required final int sizeBytes,
      required final Duration estimatedTimeLeft,
      required final int downloadBytesPerSecond,
      required final bool downloadLimited,
      required final int uploadBytesPerSecond,
      required final bool uploadLimited,
      required final TorrentState state,
      required final TorrentPriority priority,
      final DateTime? addedOn,
      final DateTime? completedOn}) = _$_TorrentQuickData;

  factory _TorrentQuickData.fromJson(Map<String, dynamic> json) =
      _$_TorrentQuickData.fromJson;

  @override
  int get id;
  @override
  String get name;
  @override
  int get downloadedBytes;
  @override
  int get sizeToDownloadBytes;
  @override
  int get sizeBytes;
  @override
  Duration get estimatedTimeLeft;
  @override
  int get downloadBytesPerSecond;
  @override
  bool get downloadLimited;
  @override
  int get uploadBytesPerSecond;
  @override
  bool get uploadLimited;
  @override
  TorrentState get state;
  @override
  TorrentPriority get priority;
  @override
  DateTime? get addedOn;
  @override
  DateTime? get completedOn;
  @override
  @JsonKey(ignore: true)
  _$$_TorrentQuickDataCopyWith<_$_TorrentQuickData> get copyWith =>
      throw _privateConstructorUsedError;
}

TorrentData _$TorrentDataFromJson(Map<String, dynamic> json) {
  return _TorrentData.fromJson(json);
}

/// @nodoc
mixin _$TorrentData {
  int get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  int get downloadedBytes => throw _privateConstructorUsedError;
  int get sizeToDownloadBytes => throw _privateConstructorUsedError;
  int get sizeBytes => throw _privateConstructorUsedError;
  Duration get estimatedTimeLeft => throw _privateConstructorUsedError;
  int get downloadBytesPerSecond => throw _privateConstructorUsedError;
  int get uploadBytesPerSecond => throw _privateConstructorUsedError;
  TorrentState get state => throw _privateConstructorUsedError;
  bool get downloadLimited => throw _privateConstructorUsedError;
  bool get uploadLimited => throw _privateConstructorUsedError;
  int get downloadLimitBytesPerSecond => throw _privateConstructorUsedError;
  int get uploadLimitBytesPerSecond => throw _privateConstructorUsedError;
  TorrentPriority get priority => throw _privateConstructorUsedError;
  DateTime? get addedOn => throw _privateConstructorUsedError;
  DateTime? get completedOn => throw _privateConstructorUsedError;
  DateTime? get lastActivity => throw _privateConstructorUsedError;
  String? get location => throw _privateConstructorUsedError;
  String? get magnet => throw _privateConstructorUsedError;
  String? get torrentFileLocation => throw _privateConstructorUsedError;
  double get ratio => throw _privateConstructorUsedError;
  int? get uploadedEverBytes => throw _privateConstructorUsedError;
  int? get downloadedEverBytes => throw _privateConstructorUsedError;
  Duration? get timeDownloading => throw _privateConstructorUsedError;
  Duration? get timeSeeding => throw _privateConstructorUsedError;
  List<TorrentFileData> get files => throw _privateConstructorUsedError;
  List<String> get peers => throw _privateConstructorUsedError;
  List<String> get trackers => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TorrentDataCopyWith<TorrentData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TorrentDataCopyWith<$Res> {
  factory $TorrentDataCopyWith(
          TorrentData value, $Res Function(TorrentData) then) =
      _$TorrentDataCopyWithImpl<$Res, TorrentData>;
  @useResult
  $Res call(
      {int id,
      String name,
      int downloadedBytes,
      int sizeToDownloadBytes,
      int sizeBytes,
      Duration estimatedTimeLeft,
      int downloadBytesPerSecond,
      int uploadBytesPerSecond,
      TorrentState state,
      bool downloadLimited,
      bool uploadLimited,
      int downloadLimitBytesPerSecond,
      int uploadLimitBytesPerSecond,
      TorrentPriority priority,
      DateTime? addedOn,
      DateTime? completedOn,
      DateTime? lastActivity,
      String? location,
      String? magnet,
      String? torrentFileLocation,
      double ratio,
      int? uploadedEverBytes,
      int? downloadedEverBytes,
      Duration? timeDownloading,
      Duration? timeSeeding,
      List<TorrentFileData> files,
      List<String> peers,
      List<String> trackers});
}

/// @nodoc
class _$TorrentDataCopyWithImpl<$Res, $Val extends TorrentData>
    implements $TorrentDataCopyWith<$Res> {
  _$TorrentDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? downloadedBytes = null,
    Object? sizeToDownloadBytes = null,
    Object? sizeBytes = null,
    Object? estimatedTimeLeft = null,
    Object? downloadBytesPerSecond = null,
    Object? uploadBytesPerSecond = null,
    Object? state = null,
    Object? downloadLimited = null,
    Object? uploadLimited = null,
    Object? downloadLimitBytesPerSecond = null,
    Object? uploadLimitBytesPerSecond = null,
    Object? priority = null,
    Object? addedOn = freezed,
    Object? completedOn = freezed,
    Object? lastActivity = freezed,
    Object? location = freezed,
    Object? magnet = freezed,
    Object? torrentFileLocation = freezed,
    Object? ratio = null,
    Object? uploadedEverBytes = freezed,
    Object? downloadedEverBytes = freezed,
    Object? timeDownloading = freezed,
    Object? timeSeeding = freezed,
    Object? files = null,
    Object? peers = null,
    Object? trackers = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      downloadedBytes: null == downloadedBytes
          ? _value.downloadedBytes
          : downloadedBytes // ignore: cast_nullable_to_non_nullable
              as int,
      sizeToDownloadBytes: null == sizeToDownloadBytes
          ? _value.sizeToDownloadBytes
          : sizeToDownloadBytes // ignore: cast_nullable_to_non_nullable
              as int,
      sizeBytes: null == sizeBytes
          ? _value.sizeBytes
          : sizeBytes // ignore: cast_nullable_to_non_nullable
              as int,
      estimatedTimeLeft: null == estimatedTimeLeft
          ? _value.estimatedTimeLeft
          : estimatedTimeLeft // ignore: cast_nullable_to_non_nullable
              as Duration,
      downloadBytesPerSecond: null == downloadBytesPerSecond
          ? _value.downloadBytesPerSecond
          : downloadBytesPerSecond // ignore: cast_nullable_to_non_nullable
              as int,
      uploadBytesPerSecond: null == uploadBytesPerSecond
          ? _value.uploadBytesPerSecond
          : uploadBytesPerSecond // ignore: cast_nullable_to_non_nullable
              as int,
      state: null == state
          ? _value.state
          : state // ignore: cast_nullable_to_non_nullable
              as TorrentState,
      downloadLimited: null == downloadLimited
          ? _value.downloadLimited
          : downloadLimited // ignore: cast_nullable_to_non_nullable
              as bool,
      uploadLimited: null == uploadLimited
          ? _value.uploadLimited
          : uploadLimited // ignore: cast_nullable_to_non_nullable
              as bool,
      downloadLimitBytesPerSecond: null == downloadLimitBytesPerSecond
          ? _value.downloadLimitBytesPerSecond
          : downloadLimitBytesPerSecond // ignore: cast_nullable_to_non_nullable
              as int,
      uploadLimitBytesPerSecond: null == uploadLimitBytesPerSecond
          ? _value.uploadLimitBytesPerSecond
          : uploadLimitBytesPerSecond // ignore: cast_nullable_to_non_nullable
              as int,
      priority: null == priority
          ? _value.priority
          : priority // ignore: cast_nullable_to_non_nullable
              as TorrentPriority,
      addedOn: freezed == addedOn
          ? _value.addedOn
          : addedOn // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      completedOn: freezed == completedOn
          ? _value.completedOn
          : completedOn // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastActivity: freezed == lastActivity
          ? _value.lastActivity
          : lastActivity // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      location: freezed == location
          ? _value.location
          : location // ignore: cast_nullable_to_non_nullable
              as String?,
      magnet: freezed == magnet
          ? _value.magnet
          : magnet // ignore: cast_nullable_to_non_nullable
              as String?,
      torrentFileLocation: freezed == torrentFileLocation
          ? _value.torrentFileLocation
          : torrentFileLocation // ignore: cast_nullable_to_non_nullable
              as String?,
      ratio: null == ratio
          ? _value.ratio
          : ratio // ignore: cast_nullable_to_non_nullable
              as double,
      uploadedEverBytes: freezed == uploadedEverBytes
          ? _value.uploadedEverBytes
          : uploadedEverBytes // ignore: cast_nullable_to_non_nullable
              as int?,
      downloadedEverBytes: freezed == downloadedEverBytes
          ? _value.downloadedEverBytes
          : downloadedEverBytes // ignore: cast_nullable_to_non_nullable
              as int?,
      timeDownloading: freezed == timeDownloading
          ? _value.timeDownloading
          : timeDownloading // ignore: cast_nullable_to_non_nullable
              as Duration?,
      timeSeeding: freezed == timeSeeding
          ? _value.timeSeeding
          : timeSeeding // ignore: cast_nullable_to_non_nullable
              as Duration?,
      files: null == files
          ? _value.files
          : files // ignore: cast_nullable_to_non_nullable
              as List<TorrentFileData>,
      peers: null == peers
          ? _value.peers
          : peers // ignore: cast_nullable_to_non_nullable
              as List<String>,
      trackers: null == trackers
          ? _value.trackers
          : trackers // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_TorrentDataCopyWith<$Res>
    implements $TorrentDataCopyWith<$Res> {
  factory _$$_TorrentDataCopyWith(
          _$_TorrentData value, $Res Function(_$_TorrentData) then) =
      __$$_TorrentDataCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int id,
      String name,
      int downloadedBytes,
      int sizeToDownloadBytes,
      int sizeBytes,
      Duration estimatedTimeLeft,
      int downloadBytesPerSecond,
      int uploadBytesPerSecond,
      TorrentState state,
      bool downloadLimited,
      bool uploadLimited,
      int downloadLimitBytesPerSecond,
      int uploadLimitBytesPerSecond,
      TorrentPriority priority,
      DateTime? addedOn,
      DateTime? completedOn,
      DateTime? lastActivity,
      String? location,
      String? magnet,
      String? torrentFileLocation,
      double ratio,
      int? uploadedEverBytes,
      int? downloadedEverBytes,
      Duration? timeDownloading,
      Duration? timeSeeding,
      List<TorrentFileData> files,
      List<String> peers,
      List<String> trackers});
}

/// @nodoc
class __$$_TorrentDataCopyWithImpl<$Res>
    extends _$TorrentDataCopyWithImpl<$Res, _$_TorrentData>
    implements _$$_TorrentDataCopyWith<$Res> {
  __$$_TorrentDataCopyWithImpl(
      _$_TorrentData _value, $Res Function(_$_TorrentData) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? downloadedBytes = null,
    Object? sizeToDownloadBytes = null,
    Object? sizeBytes = null,
    Object? estimatedTimeLeft = null,
    Object? downloadBytesPerSecond = null,
    Object? uploadBytesPerSecond = null,
    Object? state = null,
    Object? downloadLimited = null,
    Object? uploadLimited = null,
    Object? downloadLimitBytesPerSecond = null,
    Object? uploadLimitBytesPerSecond = null,
    Object? priority = null,
    Object? addedOn = freezed,
    Object? completedOn = freezed,
    Object? lastActivity = freezed,
    Object? location = freezed,
    Object? magnet = freezed,
    Object? torrentFileLocation = freezed,
    Object? ratio = null,
    Object? uploadedEverBytes = freezed,
    Object? downloadedEverBytes = freezed,
    Object? timeDownloading = freezed,
    Object? timeSeeding = freezed,
    Object? files = null,
    Object? peers = null,
    Object? trackers = null,
  }) {
    return _then(_$_TorrentData(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      downloadedBytes: null == downloadedBytes
          ? _value.downloadedBytes
          : downloadedBytes // ignore: cast_nullable_to_non_nullable
              as int,
      sizeToDownloadBytes: null == sizeToDownloadBytes
          ? _value.sizeToDownloadBytes
          : sizeToDownloadBytes // ignore: cast_nullable_to_non_nullable
              as int,
      sizeBytes: null == sizeBytes
          ? _value.sizeBytes
          : sizeBytes // ignore: cast_nullable_to_non_nullable
              as int,
      estimatedTimeLeft: null == estimatedTimeLeft
          ? _value.estimatedTimeLeft
          : estimatedTimeLeft // ignore: cast_nullable_to_non_nullable
              as Duration,
      downloadBytesPerSecond: null == downloadBytesPerSecond
          ? _value.downloadBytesPerSecond
          : downloadBytesPerSecond // ignore: cast_nullable_to_non_nullable
              as int,
      uploadBytesPerSecond: null == uploadBytesPerSecond
          ? _value.uploadBytesPerSecond
          : uploadBytesPerSecond // ignore: cast_nullable_to_non_nullable
              as int,
      state: null == state
          ? _value.state
          : state // ignore: cast_nullable_to_non_nullable
              as TorrentState,
      downloadLimited: null == downloadLimited
          ? _value.downloadLimited
          : downloadLimited // ignore: cast_nullable_to_non_nullable
              as bool,
      uploadLimited: null == uploadLimited
          ? _value.uploadLimited
          : uploadLimited // ignore: cast_nullable_to_non_nullable
              as bool,
      downloadLimitBytesPerSecond: null == downloadLimitBytesPerSecond
          ? _value.downloadLimitBytesPerSecond
          : downloadLimitBytesPerSecond // ignore: cast_nullable_to_non_nullable
              as int,
      uploadLimitBytesPerSecond: null == uploadLimitBytesPerSecond
          ? _value.uploadLimitBytesPerSecond
          : uploadLimitBytesPerSecond // ignore: cast_nullable_to_non_nullable
              as int,
      priority: null == priority
          ? _value.priority
          : priority // ignore: cast_nullable_to_non_nullable
              as TorrentPriority,
      addedOn: freezed == addedOn
          ? _value.addedOn
          : addedOn // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      completedOn: freezed == completedOn
          ? _value.completedOn
          : completedOn // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastActivity: freezed == lastActivity
          ? _value.lastActivity
          : lastActivity // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      location: freezed == location
          ? _value.location
          : location // ignore: cast_nullable_to_non_nullable
              as String?,
      magnet: freezed == magnet
          ? _value.magnet
          : magnet // ignore: cast_nullable_to_non_nullable
              as String?,
      torrentFileLocation: freezed == torrentFileLocation
          ? _value.torrentFileLocation
          : torrentFileLocation // ignore: cast_nullable_to_non_nullable
              as String?,
      ratio: null == ratio
          ? _value.ratio
          : ratio // ignore: cast_nullable_to_non_nullable
              as double,
      uploadedEverBytes: freezed == uploadedEverBytes
          ? _value.uploadedEverBytes
          : uploadedEverBytes // ignore: cast_nullable_to_non_nullable
              as int?,
      downloadedEverBytes: freezed == downloadedEverBytes
          ? _value.downloadedEverBytes
          : downloadedEverBytes // ignore: cast_nullable_to_non_nullable
              as int?,
      timeDownloading: freezed == timeDownloading
          ? _value.timeDownloading
          : timeDownloading // ignore: cast_nullable_to_non_nullable
              as Duration?,
      timeSeeding: freezed == timeSeeding
          ? _value.timeSeeding
          : timeSeeding // ignore: cast_nullable_to_non_nullable
              as Duration?,
      files: null == files
          ? _value._files
          : files // ignore: cast_nullable_to_non_nullable
              as List<TorrentFileData>,
      peers: null == peers
          ? _value._peers
          : peers // ignore: cast_nullable_to_non_nullable
              as List<String>,
      trackers: null == trackers
          ? _value._trackers
          : trackers // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_TorrentData with DiagnosticableTreeMixin implements _TorrentData {
  const _$_TorrentData(
      {required this.id,
      required this.name,
      required this.downloadedBytes,
      required this.sizeToDownloadBytes,
      required this.sizeBytes,
      required this.estimatedTimeLeft,
      required this.downloadBytesPerSecond,
      required this.uploadBytesPerSecond,
      required this.state,
      required this.downloadLimited,
      required this.uploadLimited,
      required this.downloadLimitBytesPerSecond,
      required this.uploadLimitBytesPerSecond,
      required this.priority,
      this.addedOn,
      this.completedOn,
      this.lastActivity,
      this.location,
      this.magnet,
      this.torrentFileLocation,
      required this.ratio,
      this.uploadedEverBytes,
      this.downloadedEverBytes,
      this.timeDownloading,
      this.timeSeeding,
      required final List<TorrentFileData> files,
      required final List<String> peers,
      required final List<String> trackers})
      : _files = files,
        _peers = peers,
        _trackers = trackers;

  factory _$_TorrentData.fromJson(Map<String, dynamic> json) =>
      _$$_TorrentDataFromJson(json);

  @override
  final int id;
  @override
  final String name;
  @override
  final int downloadedBytes;
  @override
  final int sizeToDownloadBytes;
  @override
  final int sizeBytes;
  @override
  final Duration estimatedTimeLeft;
  @override
  final int downloadBytesPerSecond;
  @override
  final int uploadBytesPerSecond;
  @override
  final TorrentState state;
  @override
  final bool downloadLimited;
  @override
  final bool uploadLimited;
  @override
  final int downloadLimitBytesPerSecond;
  @override
  final int uploadLimitBytesPerSecond;
  @override
  final TorrentPriority priority;
  @override
  final DateTime? addedOn;
  @override
  final DateTime? completedOn;
  @override
  final DateTime? lastActivity;
  @override
  final String? location;
  @override
  final String? magnet;
  @override
  final String? torrentFileLocation;
  @override
  final double ratio;
  @override
  final int? uploadedEverBytes;
  @override
  final int? downloadedEverBytes;
  @override
  final Duration? timeDownloading;
  @override
  final Duration? timeSeeding;
  final List<TorrentFileData> _files;
  @override
  List<TorrentFileData> get files {
    if (_files is EqualUnmodifiableListView) return _files;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_files);
  }

  final List<String> _peers;
  @override
  List<String> get peers {
    if (_peers is EqualUnmodifiableListView) return _peers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_peers);
  }

  final List<String> _trackers;
  @override
  List<String> get trackers {
    if (_trackers is EqualUnmodifiableListView) return _trackers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_trackers);
  }

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'TorrentData(id: $id, name: $name, downloadedBytes: $downloadedBytes, sizeToDownloadBytes: $sizeToDownloadBytes, sizeBytes: $sizeBytes, estimatedTimeLeft: $estimatedTimeLeft, downloadBytesPerSecond: $downloadBytesPerSecond, uploadBytesPerSecond: $uploadBytesPerSecond, state: $state, downloadLimited: $downloadLimited, uploadLimited: $uploadLimited, downloadLimitBytesPerSecond: $downloadLimitBytesPerSecond, uploadLimitBytesPerSecond: $uploadLimitBytesPerSecond, priority: $priority, addedOn: $addedOn, completedOn: $completedOn, lastActivity: $lastActivity, location: $location, magnet: $magnet, torrentFileLocation: $torrentFileLocation, ratio: $ratio, uploadedEverBytes: $uploadedEverBytes, downloadedEverBytes: $downloadedEverBytes, timeDownloading: $timeDownloading, timeSeeding: $timeSeeding, files: $files, peers: $peers, trackers: $trackers)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'TorrentData'))
      ..add(DiagnosticsProperty('id', id))
      ..add(DiagnosticsProperty('name', name))
      ..add(DiagnosticsProperty('downloadedBytes', downloadedBytes))
      ..add(DiagnosticsProperty('sizeToDownloadBytes', sizeToDownloadBytes))
      ..add(DiagnosticsProperty('sizeBytes', sizeBytes))
      ..add(DiagnosticsProperty('estimatedTimeLeft', estimatedTimeLeft))
      ..add(
          DiagnosticsProperty('downloadBytesPerSecond', downloadBytesPerSecond))
      ..add(DiagnosticsProperty('uploadBytesPerSecond', uploadBytesPerSecond))
      ..add(DiagnosticsProperty('state', state))
      ..add(DiagnosticsProperty('downloadLimited', downloadLimited))
      ..add(DiagnosticsProperty('uploadLimited', uploadLimited))
      ..add(DiagnosticsProperty(
          'downloadLimitBytesPerSecond', downloadLimitBytesPerSecond))
      ..add(DiagnosticsProperty(
          'uploadLimitBytesPerSecond', uploadLimitBytesPerSecond))
      ..add(DiagnosticsProperty('priority', priority))
      ..add(DiagnosticsProperty('addedOn', addedOn))
      ..add(DiagnosticsProperty('completedOn', completedOn))
      ..add(DiagnosticsProperty('lastActivity', lastActivity))
      ..add(DiagnosticsProperty('location', location))
      ..add(DiagnosticsProperty('magnet', magnet))
      ..add(DiagnosticsProperty('torrentFileLocation', torrentFileLocation))
      ..add(DiagnosticsProperty('ratio', ratio))
      ..add(DiagnosticsProperty('uploadedEverBytes', uploadedEverBytes))
      ..add(DiagnosticsProperty('downloadedEverBytes', downloadedEverBytes))
      ..add(DiagnosticsProperty('timeDownloading', timeDownloading))
      ..add(DiagnosticsProperty('timeSeeding', timeSeeding))
      ..add(DiagnosticsProperty('files', files))
      ..add(DiagnosticsProperty('peers', peers))
      ..add(DiagnosticsProperty('trackers', trackers));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TorrentData &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.downloadedBytes, downloadedBytes) ||
                other.downloadedBytes == downloadedBytes) &&
            (identical(other.sizeToDownloadBytes, sizeToDownloadBytes) ||
                other.sizeToDownloadBytes == sizeToDownloadBytes) &&
            (identical(other.sizeBytes, sizeBytes) ||
                other.sizeBytes == sizeBytes) &&
            (identical(other.estimatedTimeLeft, estimatedTimeLeft) ||
                other.estimatedTimeLeft == estimatedTimeLeft) &&
            (identical(other.downloadBytesPerSecond, downloadBytesPerSecond) ||
                other.downloadBytesPerSecond == downloadBytesPerSecond) &&
            (identical(other.uploadBytesPerSecond, uploadBytesPerSecond) ||
                other.uploadBytesPerSecond == uploadBytesPerSecond) &&
            (identical(other.state, state) || other.state == state) &&
            (identical(other.downloadLimited, downloadLimited) ||
                other.downloadLimited == downloadLimited) &&
            (identical(other.uploadLimited, uploadLimited) ||
                other.uploadLimited == uploadLimited) &&
            (identical(other.downloadLimitBytesPerSecond,
                    downloadLimitBytesPerSecond) ||
                other.downloadLimitBytesPerSecond ==
                    downloadLimitBytesPerSecond) &&
            (identical(other.uploadLimitBytesPerSecond,
                    uploadLimitBytesPerSecond) ||
                other.uploadLimitBytesPerSecond == uploadLimitBytesPerSecond) &&
            (identical(other.priority, priority) ||
                other.priority == priority) &&
            (identical(other.addedOn, addedOn) || other.addedOn == addedOn) &&
            (identical(other.completedOn, completedOn) ||
                other.completedOn == completedOn) &&
            (identical(other.lastActivity, lastActivity) ||
                other.lastActivity == lastActivity) &&
            (identical(other.location, location) ||
                other.location == location) &&
            (identical(other.magnet, magnet) || other.magnet == magnet) &&
            (identical(other.torrentFileLocation, torrentFileLocation) ||
                other.torrentFileLocation == torrentFileLocation) &&
            (identical(other.ratio, ratio) || other.ratio == ratio) &&
            (identical(other.uploadedEverBytes, uploadedEverBytes) ||
                other.uploadedEverBytes == uploadedEverBytes) &&
            (identical(other.downloadedEverBytes, downloadedEverBytes) ||
                other.downloadedEverBytes == downloadedEverBytes) &&
            (identical(other.timeDownloading, timeDownloading) ||
                other.timeDownloading == timeDownloading) &&
            (identical(other.timeSeeding, timeSeeding) ||
                other.timeSeeding == timeSeeding) &&
            const DeepCollectionEquality().equals(other._files, _files) &&
            const DeepCollectionEquality().equals(other._peers, _peers) &&
            const DeepCollectionEquality().equals(other._trackers, _trackers));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        name,
        downloadedBytes,
        sizeToDownloadBytes,
        sizeBytes,
        estimatedTimeLeft,
        downloadBytesPerSecond,
        uploadBytesPerSecond,
        state,
        downloadLimited,
        uploadLimited,
        downloadLimitBytesPerSecond,
        uploadLimitBytesPerSecond,
        priority,
        addedOn,
        completedOn,
        lastActivity,
        location,
        magnet,
        torrentFileLocation,
        ratio,
        uploadedEverBytes,
        downloadedEverBytes,
        timeDownloading,
        timeSeeding,
        const DeepCollectionEquality().hash(_files),
        const DeepCollectionEquality().hash(_peers),
        const DeepCollectionEquality().hash(_trackers)
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_TorrentDataCopyWith<_$_TorrentData> get copyWith =>
      __$$_TorrentDataCopyWithImpl<_$_TorrentData>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TorrentDataToJson(
      this,
    );
  }
}

abstract class _TorrentData implements TorrentData {
  const factory _TorrentData(
      {required final int id,
      required final String name,
      required final int downloadedBytes,
      required final int sizeToDownloadBytes,
      required final int sizeBytes,
      required final Duration estimatedTimeLeft,
      required final int downloadBytesPerSecond,
      required final int uploadBytesPerSecond,
      required final TorrentState state,
      required final bool downloadLimited,
      required final bool uploadLimited,
      required final int downloadLimitBytesPerSecond,
      required final int uploadLimitBytesPerSecond,
      required final TorrentPriority priority,
      final DateTime? addedOn,
      final DateTime? completedOn,
      final DateTime? lastActivity,
      final String? location,
      final String? magnet,
      final String? torrentFileLocation,
      required final double ratio,
      final int? uploadedEverBytes,
      final int? downloadedEverBytes,
      final Duration? timeDownloading,
      final Duration? timeSeeding,
      required final List<TorrentFileData> files,
      required final List<String> peers,
      required final List<String> trackers}) = _$_TorrentData;

  factory _TorrentData.fromJson(Map<String, dynamic> json) =
      _$_TorrentData.fromJson;

  @override
  int get id;
  @override
  String get name;
  @override
  int get downloadedBytes;
  @override
  int get sizeToDownloadBytes;
  @override
  int get sizeBytes;
  @override
  Duration get estimatedTimeLeft;
  @override
  int get downloadBytesPerSecond;
  @override
  int get uploadBytesPerSecond;
  @override
  TorrentState get state;
  @override
  bool get downloadLimited;
  @override
  bool get uploadLimited;
  @override
  int get downloadLimitBytesPerSecond;
  @override
  int get uploadLimitBytesPerSecond;
  @override
  TorrentPriority get priority;
  @override
  DateTime? get addedOn;
  @override
  DateTime? get completedOn;
  @override
  DateTime? get lastActivity;
  @override
  String? get location;
  @override
  String? get magnet;
  @override
  String? get torrentFileLocation;
  @override
  double get ratio;
  @override
  int? get uploadedEverBytes;
  @override
  int? get downloadedEverBytes;
  @override
  Duration? get timeDownloading;
  @override
  Duration? get timeSeeding;
  @override
  List<TorrentFileData> get files;
  @override
  List<String> get peers;
  @override
  List<String> get trackers;
  @override
  @JsonKey(ignore: true)
  _$$_TorrentDataCopyWith<_$_TorrentData> get copyWith =>
      throw _privateConstructorUsedError;
}

TorrentFileData _$TorrentFileDataFromJson(Map<String, dynamic> json) {
  return _TorrentFileData.fromJson(json);
}

/// @nodoc
mixin _$TorrentFileData {
  String get name => throw _privateConstructorUsedError;
  int get downloadedBytes => throw _privateConstructorUsedError;
  int get sizeBytes => throw _privateConstructorUsedError;
  TorrentPriority get priority => throw _privateConstructorUsedError;
  TorrentState get state => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TorrentFileDataCopyWith<TorrentFileData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TorrentFileDataCopyWith<$Res> {
  factory $TorrentFileDataCopyWith(
          TorrentFileData value, $Res Function(TorrentFileData) then) =
      _$TorrentFileDataCopyWithImpl<$Res, TorrentFileData>;
  @useResult
  $Res call(
      {String name,
      int downloadedBytes,
      int sizeBytes,
      TorrentPriority priority,
      TorrentState state});
}

/// @nodoc
class _$TorrentFileDataCopyWithImpl<$Res, $Val extends TorrentFileData>
    implements $TorrentFileDataCopyWith<$Res> {
  _$TorrentFileDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? downloadedBytes = null,
    Object? sizeBytes = null,
    Object? priority = null,
    Object? state = null,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      downloadedBytes: null == downloadedBytes
          ? _value.downloadedBytes
          : downloadedBytes // ignore: cast_nullable_to_non_nullable
              as int,
      sizeBytes: null == sizeBytes
          ? _value.sizeBytes
          : sizeBytes // ignore: cast_nullable_to_non_nullable
              as int,
      priority: null == priority
          ? _value.priority
          : priority // ignore: cast_nullable_to_non_nullable
              as TorrentPriority,
      state: null == state
          ? _value.state
          : state // ignore: cast_nullable_to_non_nullable
              as TorrentState,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_TorrentFileDataCopyWith<$Res>
    implements $TorrentFileDataCopyWith<$Res> {
  factory _$$_TorrentFileDataCopyWith(
          _$_TorrentFileData value, $Res Function(_$_TorrentFileData) then) =
      __$$_TorrentFileDataCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String name,
      int downloadedBytes,
      int sizeBytes,
      TorrentPriority priority,
      TorrentState state});
}

/// @nodoc
class __$$_TorrentFileDataCopyWithImpl<$Res>
    extends _$TorrentFileDataCopyWithImpl<$Res, _$_TorrentFileData>
    implements _$$_TorrentFileDataCopyWith<$Res> {
  __$$_TorrentFileDataCopyWithImpl(
      _$_TorrentFileData _value, $Res Function(_$_TorrentFileData) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? downloadedBytes = null,
    Object? sizeBytes = null,
    Object? priority = null,
    Object? state = null,
  }) {
    return _then(_$_TorrentFileData(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      downloadedBytes: null == downloadedBytes
          ? _value.downloadedBytes
          : downloadedBytes // ignore: cast_nullable_to_non_nullable
              as int,
      sizeBytes: null == sizeBytes
          ? _value.sizeBytes
          : sizeBytes // ignore: cast_nullable_to_non_nullable
              as int,
      priority: null == priority
          ? _value.priority
          : priority // ignore: cast_nullable_to_non_nullable
              as TorrentPriority,
      state: null == state
          ? _value.state
          : state // ignore: cast_nullable_to_non_nullable
              as TorrentState,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_TorrentFileData
    with DiagnosticableTreeMixin
    implements _TorrentFileData {
  const _$_TorrentFileData(
      {required this.name,
      required this.downloadedBytes,
      required this.sizeBytes,
      required this.priority,
      required this.state});

  factory _$_TorrentFileData.fromJson(Map<String, dynamic> json) =>
      _$$_TorrentFileDataFromJson(json);

  @override
  final String name;
  @override
  final int downloadedBytes;
  @override
  final int sizeBytes;
  @override
  final TorrentPriority priority;
  @override
  final TorrentState state;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'TorrentFileData(name: $name, downloadedBytes: $downloadedBytes, sizeBytes: $sizeBytes, priority: $priority, state: $state)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'TorrentFileData'))
      ..add(DiagnosticsProperty('name', name))
      ..add(DiagnosticsProperty('downloadedBytes', downloadedBytes))
      ..add(DiagnosticsProperty('sizeBytes', sizeBytes))
      ..add(DiagnosticsProperty('priority', priority))
      ..add(DiagnosticsProperty('state', state));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TorrentFileData &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.downloadedBytes, downloadedBytes) ||
                other.downloadedBytes == downloadedBytes) &&
            (identical(other.sizeBytes, sizeBytes) ||
                other.sizeBytes == sizeBytes) &&
            (identical(other.priority, priority) ||
                other.priority == priority) &&
            (identical(other.state, state) || other.state == state));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, name, downloadedBytes, sizeBytes, priority, state);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_TorrentFileDataCopyWith<_$_TorrentFileData> get copyWith =>
      __$$_TorrentFileDataCopyWithImpl<_$_TorrentFileData>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TorrentFileDataToJson(
      this,
    );
  }
}

abstract class _TorrentFileData implements TorrentFileData {
  const factory _TorrentFileData(
      {required final String name,
      required final int downloadedBytes,
      required final int sizeBytes,
      required final TorrentPriority priority,
      required final TorrentState state}) = _$_TorrentFileData;

  factory _TorrentFileData.fromJson(Map<String, dynamic> json) =
      _$_TorrentFileData.fromJson;

  @override
  String get name;
  @override
  int get downloadedBytes;
  @override
  int get sizeBytes;
  @override
  TorrentPriority get priority;
  @override
  TorrentState get state;
  @override
  @JsonKey(ignore: true)
  _$$_TorrentFileDataCopyWith<_$_TorrentFileData> get copyWith =>
      throw _privateConstructorUsedError;
}

TorrentsState _$TorrentsStateFromJson(Map<String, dynamic> json) {
  return _TorrentsState.fromJson(json);
}

/// @nodoc
mixin _$TorrentsState {
  ClientState get client => throw _privateConstructorUsedError;
  Map<int, List<int>> get downloadSpeeds => throw _privateConstructorUsedError;
  Map<int, List<int>> get uploadSpeeds => throw _privateConstructorUsedError;
  List<TorrentQuickData> get quickTorrents =>
      throw _privateConstructorUsedError;
  List<TorrentData> get torrents => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TorrentsStateCopyWith<TorrentsState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TorrentsStateCopyWith<$Res> {
  factory $TorrentsStateCopyWith(
          TorrentsState value, $Res Function(TorrentsState) then) =
      _$TorrentsStateCopyWithImpl<$Res, TorrentsState>;
  @useResult
  $Res call(
      {ClientState client,
      Map<int, List<int>> downloadSpeeds,
      Map<int, List<int>> uploadSpeeds,
      List<TorrentQuickData> quickTorrents,
      List<TorrentData> torrents});

  $ClientStateCopyWith<$Res> get client;
}

/// @nodoc
class _$TorrentsStateCopyWithImpl<$Res, $Val extends TorrentsState>
    implements $TorrentsStateCopyWith<$Res> {
  _$TorrentsStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? client = null,
    Object? downloadSpeeds = null,
    Object? uploadSpeeds = null,
    Object? quickTorrents = null,
    Object? torrents = null,
  }) {
    return _then(_value.copyWith(
      client: null == client
          ? _value.client
          : client // ignore: cast_nullable_to_non_nullable
              as ClientState,
      downloadSpeeds: null == downloadSpeeds
          ? _value.downloadSpeeds
          : downloadSpeeds // ignore: cast_nullable_to_non_nullable
              as Map<int, List<int>>,
      uploadSpeeds: null == uploadSpeeds
          ? _value.uploadSpeeds
          : uploadSpeeds // ignore: cast_nullable_to_non_nullable
              as Map<int, List<int>>,
      quickTorrents: null == quickTorrents
          ? _value.quickTorrents
          : quickTorrents // ignore: cast_nullable_to_non_nullable
              as List<TorrentQuickData>,
      torrents: null == torrents
          ? _value.torrents
          : torrents // ignore: cast_nullable_to_non_nullable
              as List<TorrentData>,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ClientStateCopyWith<$Res> get client {
    return $ClientStateCopyWith<$Res>(_value.client, (value) {
      return _then(_value.copyWith(client: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_TorrentsStateCopyWith<$Res>
    implements $TorrentsStateCopyWith<$Res> {
  factory _$$_TorrentsStateCopyWith(
          _$_TorrentsState value, $Res Function(_$_TorrentsState) then) =
      __$$_TorrentsStateCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {ClientState client,
      Map<int, List<int>> downloadSpeeds,
      Map<int, List<int>> uploadSpeeds,
      List<TorrentQuickData> quickTorrents,
      List<TorrentData> torrents});

  @override
  $ClientStateCopyWith<$Res> get client;
}

/// @nodoc
class __$$_TorrentsStateCopyWithImpl<$Res>
    extends _$TorrentsStateCopyWithImpl<$Res, _$_TorrentsState>
    implements _$$_TorrentsStateCopyWith<$Res> {
  __$$_TorrentsStateCopyWithImpl(
      _$_TorrentsState _value, $Res Function(_$_TorrentsState) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? client = null,
    Object? downloadSpeeds = null,
    Object? uploadSpeeds = null,
    Object? quickTorrents = null,
    Object? torrents = null,
  }) {
    return _then(_$_TorrentsState(
      client: null == client
          ? _value.client
          : client // ignore: cast_nullable_to_non_nullable
              as ClientState,
      downloadSpeeds: null == downloadSpeeds
          ? _value._downloadSpeeds
          : downloadSpeeds // ignore: cast_nullable_to_non_nullable
              as Map<int, List<int>>,
      uploadSpeeds: null == uploadSpeeds
          ? _value._uploadSpeeds
          : uploadSpeeds // ignore: cast_nullable_to_non_nullable
              as Map<int, List<int>>,
      quickTorrents: null == quickTorrents
          ? _value._quickTorrents
          : quickTorrents // ignore: cast_nullable_to_non_nullable
              as List<TorrentQuickData>,
      torrents: null == torrents
          ? _value._torrents
          : torrents // ignore: cast_nullable_to_non_nullable
              as List<TorrentData>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_TorrentsState with DiagnosticableTreeMixin implements _TorrentsState {
  const _$_TorrentsState(
      {required this.client,
      required final Map<int, List<int>> downloadSpeeds,
      required final Map<int, List<int>> uploadSpeeds,
      required final List<TorrentQuickData> quickTorrents,
      required final List<TorrentData> torrents})
      : _downloadSpeeds = downloadSpeeds,
        _uploadSpeeds = uploadSpeeds,
        _quickTorrents = quickTorrents,
        _torrents = torrents;

  factory _$_TorrentsState.fromJson(Map<String, dynamic> json) =>
      _$$_TorrentsStateFromJson(json);

  @override
  final ClientState client;
  final Map<int, List<int>> _downloadSpeeds;
  @override
  Map<int, List<int>> get downloadSpeeds {
    if (_downloadSpeeds is EqualUnmodifiableMapView) return _downloadSpeeds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_downloadSpeeds);
  }

  final Map<int, List<int>> _uploadSpeeds;
  @override
  Map<int, List<int>> get uploadSpeeds {
    if (_uploadSpeeds is EqualUnmodifiableMapView) return _uploadSpeeds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_uploadSpeeds);
  }

  final List<TorrentQuickData> _quickTorrents;
  @override
  List<TorrentQuickData> get quickTorrents {
    if (_quickTorrents is EqualUnmodifiableListView) return _quickTorrents;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_quickTorrents);
  }

  final List<TorrentData> _torrents;
  @override
  List<TorrentData> get torrents {
    if (_torrents is EqualUnmodifiableListView) return _torrents;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_torrents);
  }

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'TorrentsState(client: $client, downloadSpeeds: $downloadSpeeds, uploadSpeeds: $uploadSpeeds, quickTorrents: $quickTorrents, torrents: $torrents)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'TorrentsState'))
      ..add(DiagnosticsProperty('client', client))
      ..add(DiagnosticsProperty('downloadSpeeds', downloadSpeeds))
      ..add(DiagnosticsProperty('uploadSpeeds', uploadSpeeds))
      ..add(DiagnosticsProperty('quickTorrents', quickTorrents))
      ..add(DiagnosticsProperty('torrents', torrents));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TorrentsState &&
            (identical(other.client, client) || other.client == client) &&
            const DeepCollectionEquality()
                .equals(other._downloadSpeeds, _downloadSpeeds) &&
            const DeepCollectionEquality()
                .equals(other._uploadSpeeds, _uploadSpeeds) &&
            const DeepCollectionEquality()
                .equals(other._quickTorrents, _quickTorrents) &&
            const DeepCollectionEquality().equals(other._torrents, _torrents));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      client,
      const DeepCollectionEquality().hash(_downloadSpeeds),
      const DeepCollectionEquality().hash(_uploadSpeeds),
      const DeepCollectionEquality().hash(_quickTorrents),
      const DeepCollectionEquality().hash(_torrents));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_TorrentsStateCopyWith<_$_TorrentsState> get copyWith =>
      __$$_TorrentsStateCopyWithImpl<_$_TorrentsState>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TorrentsStateToJson(
      this,
    );
  }
}

abstract class _TorrentsState implements TorrentsState {
  const factory _TorrentsState(
      {required final ClientState client,
      required final Map<int, List<int>> downloadSpeeds,
      required final Map<int, List<int>> uploadSpeeds,
      required final List<TorrentQuickData> quickTorrents,
      required final List<TorrentData> torrents}) = _$_TorrentsState;

  factory _TorrentsState.fromJson(Map<String, dynamic> json) =
      _$_TorrentsState.fromJson;

  @override
  ClientState get client;
  @override
  Map<int, List<int>> get downloadSpeeds;
  @override
  Map<int, List<int>> get uploadSpeeds;
  @override
  List<TorrentQuickData> get quickTorrents;
  @override
  List<TorrentData> get torrents;
  @override
  @JsonKey(ignore: true)
  _$$_TorrentsStateCopyWith<_$_TorrentsState> get copyWith =>
      throw _privateConstructorUsedError;
}

ClientState _$ClientStateFromJson(Map<String, dynamic> json) {
  return _ClientState.fromJson(json);
}

/// @nodoc
mixin _$ClientState {
  int get downloadSpeedBytesPerSecond => throw _privateConstructorUsedError;
  int get uploadSpeedBytesPerSecond => throw _privateConstructorUsedError;
  int? get downloadLimitBytesPerSecond => throw _privateConstructorUsedError;
  int? get uploadLimitBytesPerSecond => throw _privateConstructorUsedError;
  bool get alternativeSpeedLimitsEnabled => throw _privateConstructorUsedError;
  int get freeSpaceBytes => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ClientStateCopyWith<ClientState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ClientStateCopyWith<$Res> {
  factory $ClientStateCopyWith(
          ClientState value, $Res Function(ClientState) then) =
      _$ClientStateCopyWithImpl<$Res, ClientState>;
  @useResult
  $Res call(
      {int downloadSpeedBytesPerSecond,
      int uploadSpeedBytesPerSecond,
      int? downloadLimitBytesPerSecond,
      int? uploadLimitBytesPerSecond,
      bool alternativeSpeedLimitsEnabled,
      int freeSpaceBytes});
}

/// @nodoc
class _$ClientStateCopyWithImpl<$Res, $Val extends ClientState>
    implements $ClientStateCopyWith<$Res> {
  _$ClientStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? downloadSpeedBytesPerSecond = null,
    Object? uploadSpeedBytesPerSecond = null,
    Object? downloadLimitBytesPerSecond = freezed,
    Object? uploadLimitBytesPerSecond = freezed,
    Object? alternativeSpeedLimitsEnabled = null,
    Object? freeSpaceBytes = null,
  }) {
    return _then(_value.copyWith(
      downloadSpeedBytesPerSecond: null == downloadSpeedBytesPerSecond
          ? _value.downloadSpeedBytesPerSecond
          : downloadSpeedBytesPerSecond // ignore: cast_nullable_to_non_nullable
              as int,
      uploadSpeedBytesPerSecond: null == uploadSpeedBytesPerSecond
          ? _value.uploadSpeedBytesPerSecond
          : uploadSpeedBytesPerSecond // ignore: cast_nullable_to_non_nullable
              as int,
      downloadLimitBytesPerSecond: freezed == downloadLimitBytesPerSecond
          ? _value.downloadLimitBytesPerSecond
          : downloadLimitBytesPerSecond // ignore: cast_nullable_to_non_nullable
              as int?,
      uploadLimitBytesPerSecond: freezed == uploadLimitBytesPerSecond
          ? _value.uploadLimitBytesPerSecond
          : uploadLimitBytesPerSecond // ignore: cast_nullable_to_non_nullable
              as int?,
      alternativeSpeedLimitsEnabled: null == alternativeSpeedLimitsEnabled
          ? _value.alternativeSpeedLimitsEnabled
          : alternativeSpeedLimitsEnabled // ignore: cast_nullable_to_non_nullable
              as bool,
      freeSpaceBytes: null == freeSpaceBytes
          ? _value.freeSpaceBytes
          : freeSpaceBytes // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ClientStateCopyWith<$Res>
    implements $ClientStateCopyWith<$Res> {
  factory _$$_ClientStateCopyWith(
          _$_ClientState value, $Res Function(_$_ClientState) then) =
      __$$_ClientStateCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int downloadSpeedBytesPerSecond,
      int uploadSpeedBytesPerSecond,
      int? downloadLimitBytesPerSecond,
      int? uploadLimitBytesPerSecond,
      bool alternativeSpeedLimitsEnabled,
      int freeSpaceBytes});
}

/// @nodoc
class __$$_ClientStateCopyWithImpl<$Res>
    extends _$ClientStateCopyWithImpl<$Res, _$_ClientState>
    implements _$$_ClientStateCopyWith<$Res> {
  __$$_ClientStateCopyWithImpl(
      _$_ClientState _value, $Res Function(_$_ClientState) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? downloadSpeedBytesPerSecond = null,
    Object? uploadSpeedBytesPerSecond = null,
    Object? downloadLimitBytesPerSecond = freezed,
    Object? uploadLimitBytesPerSecond = freezed,
    Object? alternativeSpeedLimitsEnabled = null,
    Object? freeSpaceBytes = null,
  }) {
    return _then(_$_ClientState(
      downloadSpeedBytesPerSecond: null == downloadSpeedBytesPerSecond
          ? _value.downloadSpeedBytesPerSecond
          : downloadSpeedBytesPerSecond // ignore: cast_nullable_to_non_nullable
              as int,
      uploadSpeedBytesPerSecond: null == uploadSpeedBytesPerSecond
          ? _value.uploadSpeedBytesPerSecond
          : uploadSpeedBytesPerSecond // ignore: cast_nullable_to_non_nullable
              as int,
      downloadLimitBytesPerSecond: freezed == downloadLimitBytesPerSecond
          ? _value.downloadLimitBytesPerSecond
          : downloadLimitBytesPerSecond // ignore: cast_nullable_to_non_nullable
              as int?,
      uploadLimitBytesPerSecond: freezed == uploadLimitBytesPerSecond
          ? _value.uploadLimitBytesPerSecond
          : uploadLimitBytesPerSecond // ignore: cast_nullable_to_non_nullable
              as int?,
      alternativeSpeedLimitsEnabled: null == alternativeSpeedLimitsEnabled
          ? _value.alternativeSpeedLimitsEnabled
          : alternativeSpeedLimitsEnabled // ignore: cast_nullable_to_non_nullable
              as bool,
      freeSpaceBytes: null == freeSpaceBytes
          ? _value.freeSpaceBytes
          : freeSpaceBytes // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ClientState with DiagnosticableTreeMixin implements _ClientState {
  const _$_ClientState(
      {required this.downloadSpeedBytesPerSecond,
      required this.uploadSpeedBytesPerSecond,
      required this.downloadLimitBytesPerSecond,
      required this.uploadLimitBytesPerSecond,
      required this.alternativeSpeedLimitsEnabled,
      required this.freeSpaceBytes});

  factory _$_ClientState.fromJson(Map<String, dynamic> json) =>
      _$$_ClientStateFromJson(json);

  @override
  final int downloadSpeedBytesPerSecond;
  @override
  final int uploadSpeedBytesPerSecond;
  @override
  final int? downloadLimitBytesPerSecond;
  @override
  final int? uploadLimitBytesPerSecond;
  @override
  final bool alternativeSpeedLimitsEnabled;
  @override
  final int freeSpaceBytes;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ClientState(downloadSpeedBytesPerSecond: $downloadSpeedBytesPerSecond, uploadSpeedBytesPerSecond: $uploadSpeedBytesPerSecond, downloadLimitBytesPerSecond: $downloadLimitBytesPerSecond, uploadLimitBytesPerSecond: $uploadLimitBytesPerSecond, alternativeSpeedLimitsEnabled: $alternativeSpeedLimitsEnabled, freeSpaceBytes: $freeSpaceBytes)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ClientState'))
      ..add(DiagnosticsProperty(
          'downloadSpeedBytesPerSecond', downloadSpeedBytesPerSecond))
      ..add(DiagnosticsProperty(
          'uploadSpeedBytesPerSecond', uploadSpeedBytesPerSecond))
      ..add(DiagnosticsProperty(
          'downloadLimitBytesPerSecond', downloadLimitBytesPerSecond))
      ..add(DiagnosticsProperty(
          'uploadLimitBytesPerSecond', uploadLimitBytesPerSecond))
      ..add(DiagnosticsProperty(
          'alternativeSpeedLimitsEnabled', alternativeSpeedLimitsEnabled))
      ..add(DiagnosticsProperty('freeSpaceBytes', freeSpaceBytes));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ClientState &&
            (identical(other.downloadSpeedBytesPerSecond,
                    downloadSpeedBytesPerSecond) ||
                other.downloadSpeedBytesPerSecond ==
                    downloadSpeedBytesPerSecond) &&
            (identical(other.uploadSpeedBytesPerSecond,
                    uploadSpeedBytesPerSecond) ||
                other.uploadSpeedBytesPerSecond == uploadSpeedBytesPerSecond) &&
            (identical(other.downloadLimitBytesPerSecond,
                    downloadLimitBytesPerSecond) ||
                other.downloadLimitBytesPerSecond ==
                    downloadLimitBytesPerSecond) &&
            (identical(other.uploadLimitBytesPerSecond,
                    uploadLimitBytesPerSecond) ||
                other.uploadLimitBytesPerSecond == uploadLimitBytesPerSecond) &&
            (identical(other.alternativeSpeedLimitsEnabled,
                    alternativeSpeedLimitsEnabled) ||
                other.alternativeSpeedLimitsEnabled ==
                    alternativeSpeedLimitsEnabled) &&
            (identical(other.freeSpaceBytes, freeSpaceBytes) ||
                other.freeSpaceBytes == freeSpaceBytes));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      downloadSpeedBytesPerSecond,
      uploadSpeedBytesPerSecond,
      downloadLimitBytesPerSecond,
      uploadLimitBytesPerSecond,
      alternativeSpeedLimitsEnabled,
      freeSpaceBytes);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ClientStateCopyWith<_$_ClientState> get copyWith =>
      __$$_ClientStateCopyWithImpl<_$_ClientState>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ClientStateToJson(
      this,
    );
  }
}

abstract class _ClientState implements ClientState {
  const factory _ClientState(
      {required final int downloadSpeedBytesPerSecond,
      required final int uploadSpeedBytesPerSecond,
      required final int? downloadLimitBytesPerSecond,
      required final int? uploadLimitBytesPerSecond,
      required final bool alternativeSpeedLimitsEnabled,
      required final int freeSpaceBytes}) = _$_ClientState;

  factory _ClientState.fromJson(Map<String, dynamic> json) =
      _$_ClientState.fromJson;

  @override
  int get downloadSpeedBytesPerSecond;
  @override
  int get uploadSpeedBytesPerSecond;
  @override
  int? get downloadLimitBytesPerSecond;
  @override
  int? get uploadLimitBytesPerSecond;
  @override
  bool get alternativeSpeedLimitsEnabled;
  @override
  int get freeSpaceBytes;
  @override
  @JsonKey(ignore: true)
  _$$_ClientStateCopyWith<_$_ClientState> get copyWith =>
      throw _privateConstructorUsedError;
}

// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'torrent.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

TorrentQuickData _$TorrentQuickDataFromJson(Map<String, dynamic> json) {
  return _TorrentQuickData.fromJson(json);
}

/// @nodoc
mixin _$TorrentQuickData {
  int get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  int get downloadedBytes => throw _privateConstructorUsedError;
  int get sizeToDownloadBytes => throw _privateConstructorUsedError;
  int get sizeBytes => throw _privateConstructorUsedError;
  Duration get estimatedTimeLeft => throw _privateConstructorUsedError;
  int get downloadBytesPerSecond => throw _privateConstructorUsedError;
  TorrentState get state => throw _privateConstructorUsedError;
  bool get limited => throw _privateConstructorUsedError;
  TorrentPriority get priority => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TorrentQuickDataCopyWith<TorrentQuickData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TorrentQuickDataCopyWith<$Res> {
  factory $TorrentQuickDataCopyWith(
          TorrentQuickData value, $Res Function(TorrentQuickData) then) =
      _$TorrentQuickDataCopyWithImpl<$Res, TorrentQuickData>;
  @useResult
  $Res call(
      {int id,
      String name,
      int downloadedBytes,
      int sizeToDownloadBytes,
      int sizeBytes,
      Duration estimatedTimeLeft,
      int downloadBytesPerSecond,
      TorrentState state,
      bool limited,
      TorrentPriority priority});
}

/// @nodoc
class _$TorrentQuickDataCopyWithImpl<$Res, $Val extends TorrentQuickData>
    implements $TorrentQuickDataCopyWith<$Res> {
  _$TorrentQuickDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? downloadedBytes = null,
    Object? sizeToDownloadBytes = null,
    Object? sizeBytes = null,
    Object? estimatedTimeLeft = null,
    Object? downloadBytesPerSecond = null,
    Object? state = null,
    Object? limited = null,
    Object? priority = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      downloadedBytes: null == downloadedBytes
          ? _value.downloadedBytes
          : downloadedBytes // ignore: cast_nullable_to_non_nullable
              as int,
      sizeToDownloadBytes: null == sizeToDownloadBytes
          ? _value.sizeToDownloadBytes
          : sizeToDownloadBytes // ignore: cast_nullable_to_non_nullable
              as int,
      sizeBytes: null == sizeBytes
          ? _value.sizeBytes
          : sizeBytes // ignore: cast_nullable_to_non_nullable
              as int,
      estimatedTimeLeft: null == estimatedTimeLeft
          ? _value.estimatedTimeLeft
          : estimatedTimeLeft // ignore: cast_nullable_to_non_nullable
              as Duration,
      downloadBytesPerSecond: null == downloadBytesPerSecond
          ? _value.downloadBytesPerSecond
          : downloadBytesPerSecond // ignore: cast_nullable_to_non_nullable
              as int,
      state: null == state
          ? _value.state
          : state // ignore: cast_nullable_to_non_nullable
              as TorrentState,
      limited: null == limited
          ? _value.limited
          : limited // ignore: cast_nullable_to_non_nullable
              as bool,
      priority: null == priority
          ? _value.priority
          : priority // ignore: cast_nullable_to_non_nullable
              as TorrentPriority,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_TorrentQuickDataCopyWith<$Res>
    implements $TorrentQuickDataCopyWith<$Res> {
  factory _$$_TorrentQuickDataCopyWith(
          _$_TorrentQuickData value, $Res Function(_$_TorrentQuickData) then) =
      __$$_TorrentQuickDataCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int id,
      String name,
      int downloadedBytes,
      int sizeToDownloadBytes,
      int sizeBytes,
      Duration estimatedTimeLeft,
      int downloadBytesPerSecond,
      TorrentState state,
      bool limited,
      TorrentPriority priority});
}

/// @nodoc
class __$$_TorrentQuickDataCopyWithImpl<$Res>
    extends _$TorrentQuickDataCopyWithImpl<$Res, _$_TorrentQuickData>
    implements _$$_TorrentQuickDataCopyWith<$Res> {
  __$$_TorrentQuickDataCopyWithImpl(
      _$_TorrentQuickData _value, $Res Function(_$_TorrentQuickData) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? downloadedBytes = null,
    Object? sizeToDownloadBytes = null,
    Object? sizeBytes = null,
    Object? estimatedTimeLeft = null,
    Object? downloadBytesPerSecond = null,
    Object? state = null,
    Object? limited = null,
    Object? priority = null,
  }) {
    return _then(_$_TorrentQuickData(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      downloadedBytes: null == downloadedBytes
          ? _value.downloadedBytes
          : downloadedBytes // ignore: cast_nullable_to_non_nullable
              as int,
      sizeToDownloadBytes: null == sizeToDownloadBytes
          ? _value.sizeToDownloadBytes
          : sizeToDownloadBytes // ignore: cast_nullable_to_non_nullable
              as int,
      sizeBytes: null == sizeBytes
          ? _value.sizeBytes
          : sizeBytes // ignore: cast_nullable_to_non_nullable
              as int,
      estimatedTimeLeft: null == estimatedTimeLeft
          ? _value.estimatedTimeLeft
          : estimatedTimeLeft // ignore: cast_nullable_to_non_nullable
              as Duration,
      downloadBytesPerSecond: null == downloadBytesPerSecond
          ? _value.downloadBytesPerSecond
          : downloadBytesPerSecond // ignore: cast_nullable_to_non_nullable
              as int,
      state: null == state
          ? _value.state
          : state // ignore: cast_nullable_to_non_nullable
              as TorrentState,
      limited: null == limited
          ? _value.limited
          : limited // ignore: cast_nullable_to_non_nullable
              as bool,
      priority: null == priority
          ? _value.priority
          : priority // ignore: cast_nullable_to_non_nullable
              as TorrentPriority,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_TorrentQuickData
    with DiagnosticableTreeMixin
    implements _TorrentQuickData {
  const _$_TorrentQuickData(
      {required this.id,
      required this.name,
      required this.downloadedBytes,
      required this.sizeToDownloadBytes,
      required this.sizeBytes,
      required this.estimatedTimeLeft,
      required this.downloadBytesPerSecond,
      required this.state,
      required this.limited,
      required this.priority});

  factory _$_TorrentQuickData.fromJson(Map<String, dynamic> json) =>
      _$$_TorrentQuickDataFromJson(json);

  @override
  final int id;
  @override
  final String name;
  @override
  final int downloadedBytes;
  @override
  final int sizeToDownloadBytes;
  @override
  final int sizeBytes;
  @override
  final Duration estimatedTimeLeft;
  @override
  final int downloadBytesPerSecond;
  @override
  final TorrentState state;
  @override
  final bool limited;
  @override
  final TorrentPriority priority;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'TorrentQuickData(id: $id, name: $name, downloadedBytes: $downloadedBytes, sizeToDownloadBytes: $sizeToDownloadBytes, sizeBytes: $sizeBytes, estimatedTimeLeft: $estimatedTimeLeft, downloadBytesPerSecond: $downloadBytesPerSecond, state: $state, limited: $limited, priority: $priority)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'TorrentQuickData'))
      ..add(DiagnosticsProperty('id', id))
      ..add(DiagnosticsProperty('name', name))
      ..add(DiagnosticsProperty('downloadedBytes', downloadedBytes))
      ..add(DiagnosticsProperty('sizeToDownloadBytes', sizeToDownloadBytes))
      ..add(DiagnosticsProperty('sizeBytes', sizeBytes))
      ..add(DiagnosticsProperty('estimatedTimeLeft', estimatedTimeLeft))
      ..add(
          DiagnosticsProperty('downloadBytesPerSecond', downloadBytesPerSecond))
      ..add(DiagnosticsProperty('state', state))
      ..add(DiagnosticsProperty('limited', limited))
      ..add(DiagnosticsProperty('priority', priority));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TorrentQuickData &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.downloadedBytes, downloadedBytes) ||
                other.downloadedBytes == downloadedBytes) &&
            (identical(other.sizeToDownloadBytes, sizeToDownloadBytes) ||
                other.sizeToDownloadBytes == sizeToDownloadBytes) &&
            (identical(other.sizeBytes, sizeBytes) ||
                other.sizeBytes == sizeBytes) &&
            (identical(other.estimatedTimeLeft, estimatedTimeLeft) ||
                other.estimatedTimeLeft == estimatedTimeLeft) &&
            (identical(other.downloadBytesPerSecond, downloadBytesPerSecond) ||
                other.downloadBytesPerSecond == downloadBytesPerSecond) &&
            (identical(other.state, state) || other.state == state) &&
            (identical(other.limited, limited) || other.limited == limited) &&
            (identical(other.priority, priority) ||
                other.priority == priority));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      name,
      downloadedBytes,
      sizeToDownloadBytes,
      sizeBytes,
      estimatedTimeLeft,
      downloadBytesPerSecond,
      state,
      limited,
      priority);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_TorrentQuickDataCopyWith<_$_TorrentQuickData> get copyWith =>
      __$$_TorrentQuickDataCopyWithImpl<_$_TorrentQuickData>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TorrentQuickDataToJson(
      this,
    );
  }
}

abstract class _TorrentQuickData implements TorrentQuickData {
  const factory _TorrentQuickData(
      {required final int id,
      required final String name,
      required final int downloadedBytes,
      required final int sizeToDownloadBytes,
      required final int sizeBytes,
      required final Duration estimatedTimeLeft,
      required final int downloadBytesPerSecond,
      required final TorrentState state,
      required final bool limited,
      required final TorrentPriority priority}) = _$_TorrentQuickData;

  factory _TorrentQuickData.fromJson(Map<String, dynamic> json) =
      _$_TorrentQuickData.fromJson;

  @override
  int get id;
  @override
  String get name;
  @override
  int get downloadedBytes;
  @override
  int get sizeToDownloadBytes;
  @override
  int get sizeBytes;
  @override
  Duration get estimatedTimeLeft;
  @override
  int get downloadBytesPerSecond;
  @override
  TorrentState get state;
  @override
  bool get limited;
  @override
  TorrentPriority get priority;
  @override
  @JsonKey(ignore: true)
  _$$_TorrentQuickDataCopyWith<_$_TorrentQuickData> get copyWith =>
      throw _privateConstructorUsedError;
}

TorrentData _$TorrentDataFromJson(Map<String, dynamic> json) {
  return _TorrentData.fromJson(json);
}

/// @nodoc
mixin _$TorrentData {
  int get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  int get downloadedBytes => throw _privateConstructorUsedError;
  int get sizeToDownloadBytes => throw _privateConstructorUsedError;
  int get sizeBytes => throw _privateConstructorUsedError;
  Duration get estimatedTimeLeft => throw _privateConstructorUsedError;
  int get downloadBytesPerSecond => throw _privateConstructorUsedError;
  int get uploadBytesPerSecond => throw _privateConstructorUsedError;
  TorrentState get state => throw _privateConstructorUsedError;
  bool get limited => throw _privateConstructorUsedError;
  TorrentPriority get priority => throw _privateConstructorUsedError;
  DateTime get addedOn => throw _privateConstructorUsedError;
  DateTime? get completedOn => throw _privateConstructorUsedError;
  String get location => throw _privateConstructorUsedError;
  double get ratio => throw _privateConstructorUsedError;
  int get uploadedBytes => throw _privateConstructorUsedError;
  String get origin => throw _privateConstructorUsedError;
  List<TorrentFileData> get files => throw _privateConstructorUsedError;
  List<String> get peers => throw _privateConstructorUsedError;
  List<String> get trackers => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TorrentDataCopyWith<TorrentData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TorrentDataCopyWith<$Res> {
  factory $TorrentDataCopyWith(
          TorrentData value, $Res Function(TorrentData) then) =
      _$TorrentDataCopyWithImpl<$Res, TorrentData>;
  @useResult
  $Res call(
      {int id,
      String name,
      int downloadedBytes,
      int sizeToDownloadBytes,
      int sizeBytes,
      Duration estimatedTimeLeft,
      int downloadBytesPerSecond,
      int uploadBytesPerSecond,
      TorrentState state,
      bool limited,
      TorrentPriority priority,
      DateTime addedOn,
      DateTime? completedOn,
      String location,
      double ratio,
      int uploadedBytes,
      String origin,
      List<TorrentFileData> files,
      List<String> peers,
      List<String> trackers});
}

/// @nodoc
class _$TorrentDataCopyWithImpl<$Res, $Val extends TorrentData>
    implements $TorrentDataCopyWith<$Res> {
  _$TorrentDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? downloadedBytes = null,
    Object? sizeToDownloadBytes = null,
    Object? sizeBytes = null,
    Object? estimatedTimeLeft = null,
    Object? downloadBytesPerSecond = null,
    Object? uploadBytesPerSecond = null,
    Object? state = null,
    Object? limited = null,
    Object? priority = null,
    Object? addedOn = null,
    Object? completedOn = freezed,
    Object? location = null,
    Object? ratio = null,
    Object? uploadedBytes = null,
    Object? origin = null,
    Object? files = null,
    Object? peers = null,
    Object? trackers = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      downloadedBytes: null == downloadedBytes
          ? _value.downloadedBytes
          : downloadedBytes // ignore: cast_nullable_to_non_nullable
              as int,
      sizeToDownloadBytes: null == sizeToDownloadBytes
          ? _value.sizeToDownloadBytes
          : sizeToDownloadBytes // ignore: cast_nullable_to_non_nullable
              as int,
      sizeBytes: null == sizeBytes
          ? _value.sizeBytes
          : sizeBytes // ignore: cast_nullable_to_non_nullable
              as int,
      estimatedTimeLeft: null == estimatedTimeLeft
          ? _value.estimatedTimeLeft
          : estimatedTimeLeft // ignore: cast_nullable_to_non_nullable
              as Duration,
      downloadBytesPerSecond: null == downloadBytesPerSecond
          ? _value.downloadBytesPerSecond
          : downloadBytesPerSecond // ignore: cast_nullable_to_non_nullable
              as int,
      uploadBytesPerSecond: null == uploadBytesPerSecond
          ? _value.uploadBytesPerSecond
          : uploadBytesPerSecond // ignore: cast_nullable_to_non_nullable
              as int,
      state: null == state
          ? _value.state
          : state // ignore: cast_nullable_to_non_nullable
              as TorrentState,
      limited: null == limited
          ? _value.limited
          : limited // ignore: cast_nullable_to_non_nullable
              as bool,
      priority: null == priority
          ? _value.priority
          : priority // ignore: cast_nullable_to_non_nullable
              as TorrentPriority,
      addedOn: null == addedOn
          ? _value.addedOn
          : addedOn // ignore: cast_nullable_to_non_nullable
              as DateTime,
      completedOn: freezed == completedOn
          ? _value.completedOn
          : completedOn // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      location: null == location
          ? _value.location
          : location // ignore: cast_nullable_to_non_nullable
              as String,
      ratio: null == ratio
          ? _value.ratio
          : ratio // ignore: cast_nullable_to_non_nullable
              as double,
      uploadedBytes: null == uploadedBytes
          ? _value.uploadedBytes
          : uploadedBytes // ignore: cast_nullable_to_non_nullable
              as int,
      origin: null == origin
          ? _value.origin
          : origin // ignore: cast_nullable_to_non_nullable
              as String,
      files: null == files
          ? _value.files
          : files // ignore: cast_nullable_to_non_nullable
              as List<TorrentFileData>,
      peers: null == peers
          ? _value.peers
          : peers // ignore: cast_nullable_to_non_nullable
              as List<String>,
      trackers: null == trackers
          ? _value.trackers
          : trackers // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_TorrentDataCopyWith<$Res>
    implements $TorrentDataCopyWith<$Res> {
  factory _$$_TorrentDataCopyWith(
          _$_TorrentData value, $Res Function(_$_TorrentData) then) =
      __$$_TorrentDataCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int id,
      String name,
      int downloadedBytes,
      int sizeToDownloadBytes,
      int sizeBytes,
      Duration estimatedTimeLeft,
      int downloadBytesPerSecond,
      int uploadBytesPerSecond,
      TorrentState state,
      bool limited,
      TorrentPriority priority,
      DateTime addedOn,
      DateTime? completedOn,
      String location,
      double ratio,
      int uploadedBytes,
      String origin,
      List<TorrentFileData> files,
      List<String> peers,
      List<String> trackers});
}

/// @nodoc
class __$$_TorrentDataCopyWithImpl<$Res>
    extends _$TorrentDataCopyWithImpl<$Res, _$_TorrentData>
    implements _$$_TorrentDataCopyWith<$Res> {
  __$$_TorrentDataCopyWithImpl(
      _$_TorrentData _value, $Res Function(_$_TorrentData) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? downloadedBytes = null,
    Object? sizeToDownloadBytes = null,
    Object? sizeBytes = null,
    Object? estimatedTimeLeft = null,
    Object? downloadBytesPerSecond = null,
    Object? uploadBytesPerSecond = null,
    Object? state = null,
    Object? limited = null,
    Object? priority = null,
    Object? addedOn = null,
    Object? completedOn = freezed,
    Object? location = null,
    Object? ratio = null,
    Object? uploadedBytes = null,
    Object? origin = null,
    Object? files = null,
    Object? peers = null,
    Object? trackers = null,
  }) {
    return _then(_$_TorrentData(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      downloadedBytes: null == downloadedBytes
          ? _value.downloadedBytes
          : downloadedBytes // ignore: cast_nullable_to_non_nullable
              as int,
      sizeToDownloadBytes: null == sizeToDownloadBytes
          ? _value.sizeToDownloadBytes
          : sizeToDownloadBytes // ignore: cast_nullable_to_non_nullable
              as int,
      sizeBytes: null == sizeBytes
          ? _value.sizeBytes
          : sizeBytes // ignore: cast_nullable_to_non_nullable
              as int,
      estimatedTimeLeft: null == estimatedTimeLeft
          ? _value.estimatedTimeLeft
          : estimatedTimeLeft // ignore: cast_nullable_to_non_nullable
              as Duration,
      downloadBytesPerSecond: null == downloadBytesPerSecond
          ? _value.downloadBytesPerSecond
          : downloadBytesPerSecond // ignore: cast_nullable_to_non_nullable
              as int,
      uploadBytesPerSecond: null == uploadBytesPerSecond
          ? _value.uploadBytesPerSecond
          : uploadBytesPerSecond // ignore: cast_nullable_to_non_nullable
              as int,
      state: null == state
          ? _value.state
          : state // ignore: cast_nullable_to_non_nullable
              as TorrentState,
      limited: null == limited
          ? _value.limited
          : limited // ignore: cast_nullable_to_non_nullable
              as bool,
      priority: null == priority
          ? _value.priority
          : priority // ignore: cast_nullable_to_non_nullable
              as TorrentPriority,
      addedOn: null == addedOn
          ? _value.addedOn
          : addedOn // ignore: cast_nullable_to_non_nullable
              as DateTime,
      completedOn: freezed == completedOn
          ? _value.completedOn
          : completedOn // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      location: null == location
          ? _value.location
          : location // ignore: cast_nullable_to_non_nullable
              as String,
      ratio: null == ratio
          ? _value.ratio
          : ratio // ignore: cast_nullable_to_non_nullable
              as double,
      uploadedBytes: null == uploadedBytes
          ? _value.uploadedBytes
          : uploadedBytes // ignore: cast_nullable_to_non_nullable
              as int,
      origin: null == origin
          ? _value.origin
          : origin // ignore: cast_nullable_to_non_nullable
              as String,
      files: null == files
          ? _value._files
          : files // ignore: cast_nullable_to_non_nullable
              as List<TorrentFileData>,
      peers: null == peers
          ? _value._peers
          : peers // ignore: cast_nullable_to_non_nullable
              as List<String>,
      trackers: null == trackers
          ? _value._trackers
          : trackers // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_TorrentData with DiagnosticableTreeMixin implements _TorrentData {
  const _$_TorrentData(
      {required this.id,
      required this.name,
      required this.downloadedBytes,
      required this.sizeToDownloadBytes,
      required this.sizeBytes,
      required this.estimatedTimeLeft,
      required this.downloadBytesPerSecond,
      required this.uploadBytesPerSecond,
      required this.state,
      required this.limited,
      required this.priority,
      required this.addedOn,
      required this.completedOn,
      required this.location,
      required this.ratio,
      required this.uploadedBytes,
      required this.origin,
      required final List<TorrentFileData> files,
      required final List<String> peers,
      required final List<String> trackers})
      : _files = files,
        _peers = peers,
        _trackers = trackers;

  factory _$_TorrentData.fromJson(Map<String, dynamic> json) =>
      _$$_TorrentDataFromJson(json);

  @override
  final int id;
  @override
  final String name;
  @override
  final int downloadedBytes;
  @override
  final int sizeToDownloadBytes;
  @override
  final int sizeBytes;
  @override
  final Duration estimatedTimeLeft;
  @override
  final int downloadBytesPerSecond;
  @override
  final int uploadBytesPerSecond;
  @override
  final TorrentState state;
  @override
  final bool limited;
  @override
  final TorrentPriority priority;
  @override
  final DateTime addedOn;
  @override
  final DateTime? completedOn;
  @override
  final String location;
  @override
  final double ratio;
  @override
  final int uploadedBytes;
  @override
  final String origin;
  final List<TorrentFileData> _files;
  @override
  List<TorrentFileData> get files {
    if (_files is EqualUnmodifiableListView) return _files;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_files);
  }

  final List<String> _peers;
  @override
  List<String> get peers {
    if (_peers is EqualUnmodifiableListView) return _peers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_peers);
  }

  final List<String> _trackers;
  @override
  List<String> get trackers {
    if (_trackers is EqualUnmodifiableListView) return _trackers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_trackers);
  }

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'TorrentData(id: $id, name: $name, downloadedBytes: $downloadedBytes, sizeToDownloadBytes: $sizeToDownloadBytes, sizeBytes: $sizeBytes, estimatedTimeLeft: $estimatedTimeLeft, downloadBytesPerSecond: $downloadBytesPerSecond, uploadBytesPerSecond: $uploadBytesPerSecond, state: $state, limited: $limited, priority: $priority, addedOn: $addedOn, completedOn: $completedOn, location: $location, ratio: $ratio, uploadedBytes: $uploadedBytes, origin: $origin, files: $files, peers: $peers, trackers: $trackers)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'TorrentData'))
      ..add(DiagnosticsProperty('id', id))
      ..add(DiagnosticsProperty('name', name))
      ..add(DiagnosticsProperty('downloadedBytes', downloadedBytes))
      ..add(DiagnosticsProperty('sizeToDownloadBytes', sizeToDownloadBytes))
      ..add(DiagnosticsProperty('sizeBytes', sizeBytes))
      ..add(DiagnosticsProperty('estimatedTimeLeft', estimatedTimeLeft))
      ..add(
          DiagnosticsProperty('downloadBytesPerSecond', downloadBytesPerSecond))
      ..add(DiagnosticsProperty('uploadBytesPerSecond', uploadBytesPerSecond))
      ..add(DiagnosticsProperty('state', state))
      ..add(DiagnosticsProperty('limited', limited))
      ..add(DiagnosticsProperty('priority', priority))
      ..add(DiagnosticsProperty('addedOn', addedOn))
      ..add(DiagnosticsProperty('completedOn', completedOn))
      ..add(DiagnosticsProperty('location', location))
      ..add(DiagnosticsProperty('ratio', ratio))
      ..add(DiagnosticsProperty('uploadedBytes', uploadedBytes))
      ..add(DiagnosticsProperty('origin', origin))
      ..add(DiagnosticsProperty('files', files))
      ..add(DiagnosticsProperty('peers', peers))
      ..add(DiagnosticsProperty('trackers', trackers));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TorrentData &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.downloadedBytes, downloadedBytes) ||
                other.downloadedBytes == downloadedBytes) &&
            (identical(other.sizeToDownloadBytes, sizeToDownloadBytes) ||
                other.sizeToDownloadBytes == sizeToDownloadBytes) &&
            (identical(other.sizeBytes, sizeBytes) ||
                other.sizeBytes == sizeBytes) &&
            (identical(other.estimatedTimeLeft, estimatedTimeLeft) ||
                other.estimatedTimeLeft == estimatedTimeLeft) &&
            (identical(other.downloadBytesPerSecond, downloadBytesPerSecond) ||
                other.downloadBytesPerSecond == downloadBytesPerSecond) &&
            (identical(other.uploadBytesPerSecond, uploadBytesPerSecond) ||
                other.uploadBytesPerSecond == uploadBytesPerSecond) &&
            (identical(other.state, state) || other.state == state) &&
            (identical(other.limited, limited) || other.limited == limited) &&
            (identical(other.priority, priority) ||
                other.priority == priority) &&
            (identical(other.addedOn, addedOn) || other.addedOn == addedOn) &&
            (identical(other.completedOn, completedOn) ||
                other.completedOn == completedOn) &&
            (identical(other.location, location) ||
                other.location == location) &&
            (identical(other.ratio, ratio) || other.ratio == ratio) &&
            (identical(other.uploadedBytes, uploadedBytes) ||
                other.uploadedBytes == uploadedBytes) &&
            (identical(other.origin, origin) || other.origin == origin) &&
            const DeepCollectionEquality().equals(other._files, _files) &&
            const DeepCollectionEquality().equals(other._peers, _peers) &&
            const DeepCollectionEquality().equals(other._trackers, _trackers));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        name,
        downloadedBytes,
        sizeToDownloadBytes,
        sizeBytes,
        estimatedTimeLeft,
        downloadBytesPerSecond,
        uploadBytesPerSecond,
        state,
        limited,
        priority,
        addedOn,
        completedOn,
        location,
        ratio,
        uploadedBytes,
        origin,
        const DeepCollectionEquality().hash(_files),
        const DeepCollectionEquality().hash(_peers),
        const DeepCollectionEquality().hash(_trackers)
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_TorrentDataCopyWith<_$_TorrentData> get copyWith =>
      __$$_TorrentDataCopyWithImpl<_$_TorrentData>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TorrentDataToJson(
      this,
    );
  }
}

abstract class _TorrentData implements TorrentData {
  const factory _TorrentData(
      {required final int id,
      required final String name,
      required final int downloadedBytes,
      required final int sizeToDownloadBytes,
      required final int sizeBytes,
      required final Duration estimatedTimeLeft,
      required final int downloadBytesPerSecond,
      required final int uploadBytesPerSecond,
      required final TorrentState state,
      required final bool limited,
      required final TorrentPriority priority,
      required final DateTime addedOn,
      required final DateTime? completedOn,
      required final String location,
      required final double ratio,
      required final int uploadedBytes,
      required final String origin,
      required final List<TorrentFileData> files,
      required final List<String> peers,
      required final List<String> trackers}) = _$_TorrentData;

  factory _TorrentData.fromJson(Map<String, dynamic> json) =
      _$_TorrentData.fromJson;

  @override
  int get id;
  @override
  String get name;
  @override
  int get downloadedBytes;
  @override
  int get sizeToDownloadBytes;
  @override
  int get sizeBytes;
  @override
  Duration get estimatedTimeLeft;
  @override
  int get downloadBytesPerSecond;
  @override
  int get uploadBytesPerSecond;
  @override
  TorrentState get state;
  @override
  bool get limited;
  @override
  TorrentPriority get priority;
  @override
  DateTime get addedOn;
  @override
  DateTime? get completedOn;
  @override
  String get location;
  @override
  double get ratio;
  @override
  int get uploadedBytes;
  @override
  String get origin;
  @override
  List<TorrentFileData> get files;
  @override
  List<String> get peers;
  @override
  List<String> get trackers;
  @override
  @JsonKey(ignore: true)
  _$$_TorrentDataCopyWith<_$_TorrentData> get copyWith =>
      throw _privateConstructorUsedError;
}

TorrentFileData _$TorrentFileDataFromJson(Map<String, dynamic> json) {
  return _TorrentFileData.fromJson(json);
}

/// @nodoc
mixin _$TorrentFileData {
  String get name => throw _privateConstructorUsedError;
  bool get wanted => throw _privateConstructorUsedError;
  int get downloadedBytes => throw _privateConstructorUsedError;
  int get sizeBytes => throw _privateConstructorUsedError;
  TorrentPriority get priority => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TorrentFileDataCopyWith<TorrentFileData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TorrentFileDataCopyWith<$Res> {
  factory $TorrentFileDataCopyWith(
          TorrentFileData value, $Res Function(TorrentFileData) then) =
      _$TorrentFileDataCopyWithImpl<$Res, TorrentFileData>;
  @useResult
  $Res call(
      {String name,
      bool wanted,
      int downloadedBytes,
      int sizeBytes,
      TorrentPriority priority});
}

/// @nodoc
class _$TorrentFileDataCopyWithImpl<$Res, $Val extends TorrentFileData>
    implements $TorrentFileDataCopyWith<$Res> {
  _$TorrentFileDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? wanted = null,
    Object? downloadedBytes = null,
    Object? sizeBytes = null,
    Object? priority = null,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      wanted: null == wanted
          ? _value.wanted
          : wanted // ignore: cast_nullable_to_non_nullable
              as bool,
      downloadedBytes: null == downloadedBytes
          ? _value.downloadedBytes
          : downloadedBytes // ignore: cast_nullable_to_non_nullable
              as int,
      sizeBytes: null == sizeBytes
          ? _value.sizeBytes
          : sizeBytes // ignore: cast_nullable_to_non_nullable
              as int,
      priority: null == priority
          ? _value.priority
          : priority // ignore: cast_nullable_to_non_nullable
              as TorrentPriority,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_TorrentFileDataCopyWith<$Res>
    implements $TorrentFileDataCopyWith<$Res> {
  factory _$$_TorrentFileDataCopyWith(
          _$_TorrentFileData value, $Res Function(_$_TorrentFileData) then) =
      __$$_TorrentFileDataCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String name,
      bool wanted,
      int downloadedBytes,
      int sizeBytes,
      TorrentPriority priority});
}

/// @nodoc
class __$$_TorrentFileDataCopyWithImpl<$Res>
    extends _$TorrentFileDataCopyWithImpl<$Res, _$_TorrentFileData>
    implements _$$_TorrentFileDataCopyWith<$Res> {
  __$$_TorrentFileDataCopyWithImpl(
      _$_TorrentFileData _value, $Res Function(_$_TorrentFileData) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? wanted = null,
    Object? downloadedBytes = null,
    Object? sizeBytes = null,
    Object? priority = null,
  }) {
    return _then(_$_TorrentFileData(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      wanted: null == wanted
          ? _value.wanted
          : wanted // ignore: cast_nullable_to_non_nullable
              as bool,
      downloadedBytes: null == downloadedBytes
          ? _value.downloadedBytes
          : downloadedBytes // ignore: cast_nullable_to_non_nullable
              as int,
      sizeBytes: null == sizeBytes
          ? _value.sizeBytes
          : sizeBytes // ignore: cast_nullable_to_non_nullable
              as int,
      priority: null == priority
          ? _value.priority
          : priority // ignore: cast_nullable_to_non_nullable
              as TorrentPriority,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_TorrentFileData
    with DiagnosticableTreeMixin
    implements _TorrentFileData {
  const _$_TorrentFileData(
      {required this.name,
      required this.wanted,
      required this.downloadedBytes,
      required this.sizeBytes,
      required this.priority});

  factory _$_TorrentFileData.fromJson(Map<String, dynamic> json) =>
      _$$_TorrentFileDataFromJson(json);

  @override
  final String name;
  @override
  final bool wanted;
  @override
  final int downloadedBytes;
  @override
  final int sizeBytes;
  @override
  final TorrentPriority priority;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'TorrentFileData(name: $name, wanted: $wanted, downloadedBytes: $downloadedBytes, sizeBytes: $sizeBytes, priority: $priority)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'TorrentFileData'))
      ..add(DiagnosticsProperty('name', name))
      ..add(DiagnosticsProperty('wanted', wanted))
      ..add(DiagnosticsProperty('downloadedBytes', downloadedBytes))
      ..add(DiagnosticsProperty('sizeBytes', sizeBytes))
      ..add(DiagnosticsProperty('priority', priority));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TorrentFileData &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.wanted, wanted) || other.wanted == wanted) &&
            (identical(other.downloadedBytes, downloadedBytes) ||
                other.downloadedBytes == downloadedBytes) &&
            (identical(other.sizeBytes, sizeBytes) ||
                other.sizeBytes == sizeBytes) &&
            (identical(other.priority, priority) ||
                other.priority == priority));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, name, wanted, downloadedBytes, sizeBytes, priority);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_TorrentFileDataCopyWith<_$_TorrentFileData> get copyWith =>
      __$$_TorrentFileDataCopyWithImpl<_$_TorrentFileData>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TorrentFileDataToJson(
      this,
    );
  }
}

abstract class _TorrentFileData implements TorrentFileData {
  const factory _TorrentFileData(
      {required final String name,
      required final bool wanted,
      required final int downloadedBytes,
      required final int sizeBytes,
      required final TorrentPriority priority}) = _$_TorrentFileData;

  factory _TorrentFileData.fromJson(Map<String, dynamic> json) =
      _$_TorrentFileData.fromJson;

  @override
  String get name;
  @override
  bool get wanted;
  @override
  int get downloadedBytes;
  @override
  int get sizeBytes;
  @override
  TorrentPriority get priority;
  @override
  @JsonKey(ignore: true)
  _$$_TorrentFileDataCopyWith<_$_TorrentFileData> get copyWith =>
      throw _privateConstructorUsedError;
}

TorrentsState _$TorrentsStateFromJson(Map<String, dynamic> json) {
  return _TorrentsState.fromJson(json);
}

/// @nodoc
mixin _$TorrentsState {
  Map<int, List<int>> get downloadSpeeds => throw _privateConstructorUsedError;
  Map<int, List<int>> get uploadSpeeds => throw _privateConstructorUsedError;
  List<TorrentQuickData> get quickTorrents =>
      throw _privateConstructorUsedError;
  List<TorrentData> get torrents => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TorrentsStateCopyWith<TorrentsState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TorrentsStateCopyWith<$Res> {
  factory $TorrentsStateCopyWith(
          TorrentsState value, $Res Function(TorrentsState) then) =
      _$TorrentsStateCopyWithImpl<$Res, TorrentsState>;
  @useResult
  $Res call(
      {Map<int, List<int>> downloadSpeeds,
      Map<int, List<int>> uploadSpeeds,
      List<TorrentQuickData> quickTorrents,
      List<TorrentData> torrents});
}

/// @nodoc
class _$TorrentsStateCopyWithImpl<$Res, $Val extends TorrentsState>
    implements $TorrentsStateCopyWith<$Res> {
  _$TorrentsStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? downloadSpeeds = null,
    Object? uploadSpeeds = null,
    Object? quickTorrents = null,
    Object? torrents = null,
  }) {
    return _then(_value.copyWith(
      downloadSpeeds: null == downloadSpeeds
          ? _value.downloadSpeeds
          : downloadSpeeds // ignore: cast_nullable_to_non_nullable
              as Map<int, List<int>>,
      uploadSpeeds: null == uploadSpeeds
          ? _value.uploadSpeeds
          : uploadSpeeds // ignore: cast_nullable_to_non_nullable
              as Map<int, List<int>>,
      quickTorrents: null == quickTorrents
          ? _value.quickTorrents
          : quickTorrents // ignore: cast_nullable_to_non_nullable
              as List<TorrentQuickData>,
      torrents: null == torrents
          ? _value.torrents
          : torrents // ignore: cast_nullable_to_non_nullable
              as List<TorrentData>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_TorrentsStateCopyWith<$Res>
    implements $TorrentsStateCopyWith<$Res> {
  factory _$$_TorrentsStateCopyWith(
          _$_TorrentsState value, $Res Function(_$_TorrentsState) then) =
      __$$_TorrentsStateCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {Map<int, List<int>> downloadSpeeds,
      Map<int, List<int>> uploadSpeeds,
      List<TorrentQuickData> quickTorrents,
      List<TorrentData> torrents});
}

/// @nodoc
class __$$_TorrentsStateCopyWithImpl<$Res>
    extends _$TorrentsStateCopyWithImpl<$Res, _$_TorrentsState>
    implements _$$_TorrentsStateCopyWith<$Res> {
  __$$_TorrentsStateCopyWithImpl(
      _$_TorrentsState _value, $Res Function(_$_TorrentsState) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? downloadSpeeds = null,
    Object? uploadSpeeds = null,
    Object? quickTorrents = null,
    Object? torrents = null,
  }) {
    return _then(_$_TorrentsState(
      downloadSpeeds: null == downloadSpeeds
          ? _value._downloadSpeeds
          : downloadSpeeds // ignore: cast_nullable_to_non_nullable
              as Map<int, List<int>>,
      uploadSpeeds: null == uploadSpeeds
          ? _value._uploadSpeeds
          : uploadSpeeds // ignore: cast_nullable_to_non_nullable
              as Map<int, List<int>>,
      quickTorrents: null == quickTorrents
          ? _value._quickTorrents
          : quickTorrents // ignore: cast_nullable_to_non_nullable
              as List<TorrentQuickData>,
      torrents: null == torrents
          ? _value._torrents
          : torrents // ignore: cast_nullable_to_non_nullable
              as List<TorrentData>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_TorrentsState with DiagnosticableTreeMixin implements _TorrentsState {
  const _$_TorrentsState(
      {required final Map<int, List<int>> downloadSpeeds,
      required final Map<int, List<int>> uploadSpeeds,
      required final List<TorrentQuickData> quickTorrents,
      required final List<TorrentData> torrents})
      : _downloadSpeeds = downloadSpeeds,
        _uploadSpeeds = uploadSpeeds,
        _quickTorrents = quickTorrents,
        _torrents = torrents;

  factory _$_TorrentsState.fromJson(Map<String, dynamic> json) =>
      _$$_TorrentsStateFromJson(json);

  final Map<int, List<int>> _downloadSpeeds;
  @override
  Map<int, List<int>> get downloadSpeeds {
    if (_downloadSpeeds is EqualUnmodifiableMapView) return _downloadSpeeds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_downloadSpeeds);
  }

  final Map<int, List<int>> _uploadSpeeds;
  @override
  Map<int, List<int>> get uploadSpeeds {
    if (_uploadSpeeds is EqualUnmodifiableMapView) return _uploadSpeeds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_uploadSpeeds);
  }

  final List<TorrentQuickData> _quickTorrents;
  @override
  List<TorrentQuickData> get quickTorrents {
    if (_quickTorrents is EqualUnmodifiableListView) return _quickTorrents;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_quickTorrents);
  }

  final List<TorrentData> _torrents;
  @override
  List<TorrentData> get torrents {
    if (_torrents is EqualUnmodifiableListView) return _torrents;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_torrents);
  }

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'TorrentsState(downloadSpeeds: $downloadSpeeds, uploadSpeeds: $uploadSpeeds, quickTorrents: $quickTorrents, torrents: $torrents)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'TorrentsState'))
      ..add(DiagnosticsProperty('downloadSpeeds', downloadSpeeds))
      ..add(DiagnosticsProperty('uploadSpeeds', uploadSpeeds))
      ..add(DiagnosticsProperty('quickTorrents', quickTorrents))
      ..add(DiagnosticsProperty('torrents', torrents));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TorrentsState &&
            const DeepCollectionEquality()
                .equals(other._downloadSpeeds, _downloadSpeeds) &&
            const DeepCollectionEquality()
                .equals(other._uploadSpeeds, _uploadSpeeds) &&
            const DeepCollectionEquality()
                .equals(other._quickTorrents, _quickTorrents) &&
            const DeepCollectionEquality().equals(other._torrents, _torrents));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_downloadSpeeds),
      const DeepCollectionEquality().hash(_uploadSpeeds),
      const DeepCollectionEquality().hash(_quickTorrents),
      const DeepCollectionEquality().hash(_torrents));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_TorrentsStateCopyWith<_$_TorrentsState> get copyWith =>
      __$$_TorrentsStateCopyWithImpl<_$_TorrentsState>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TorrentsStateToJson(
      this,
    );
  }
}

abstract class _TorrentsState implements TorrentsState {
  const factory _TorrentsState(
      {required final Map<int, List<int>> downloadSpeeds,
      required final Map<int, List<int>> uploadSpeeds,
      required final List<TorrentQuickData> quickTorrents,
      required final List<TorrentData> torrents}) = _$_TorrentsState;

  factory _TorrentsState.fromJson(Map<String, dynamic> json) =
      _$_TorrentsState.fromJson;

  @override
  Map<int, List<int>> get downloadSpeeds;
  @override
  Map<int, List<int>> get uploadSpeeds;
  @override
  List<TorrentQuickData> get quickTorrents;
  @override
  List<TorrentData> get torrents;
  @override
  @JsonKey(ignore: true)
  _$$_TorrentsStateCopyWith<_$_TorrentsState> get copyWith =>
      throw _privateConstructorUsedError;
}
